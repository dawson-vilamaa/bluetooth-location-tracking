{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\trevo\\Documents\\Capstone Project\\Project Folder\\bluetooth-location-tracking\\packages\\mongo\\mongo_driver.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.windows.x86_64"},"sourceFileName":"packages/mongo/mongo_driver.js","filename":"C:\\Users\\trevo\\Documents\\Capstone Project\\Project Folder\\bluetooth-location-tracking\\packages\\mongo\\mongo_driver.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\trevo\\Documents\\Capstone Project\\Project Folder\\bluetooth-location-tracking","root":"C:\\Users\\trevo\\Documents\\Capstone Project\\Project Folder\\bluetooth-location-tracking","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\trevo\\Documents\\Capstone Project\\Project Folder\\bluetooth-location-tracking\\packages\\mongo\\mongo_driver.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/mongo_driver.js"}},"code":"!function (module1) {\n  let _objectSpread;\n\n  module1.link(\"@babel/runtime/helpers/objectSpread2\", {\n    default(v) {\n      _objectSpread = v;\n    }\n\n  }, 0);\n  let normalizeProjection;\n  module1.link(\"./mongo_utils\", {\n    normalizeProjection(v) {\n      normalizeProjection = v;\n    }\n\n  }, 0);\n  let DocFetcher;\n  module1.link(\"./doc_fetcher.js\", {\n    DocFetcher(v) {\n      DocFetcher = v;\n    }\n\n  }, 1);\n\n  /**\n   * Provide a synchronous Collection API using fibers, backed by\n   * MongoDB.  This is only for use on the server, and mostly identical\n   * to the client API.\n   *\n   * NOTE: the public API methods must be run within a fiber. If you call\n   * these outside of a fiber they will explode!\n   */\n  const path = require(\"path\");\n\n  var MongoDB = NpmModuleMongodb;\n\n  var Future = Npm.require('fibers/future');\n\n  MongoInternals = {};\n  MongoInternals.NpmModules = {\n    mongodb: {\n      version: NpmModuleMongodbVersion,\n      module: MongoDB\n    }\n  }; // Older version of what is now available via\n  // MongoInternals.NpmModules.mongodb.module.  It was never documented, but\n  // people do use it.\n  // XXX COMPAT WITH 1.0.3.2\n\n  MongoInternals.NpmModule = MongoDB;\n  const FILE_ASSET_SUFFIX = 'Asset';\n  const ASSETS_FOLDER = 'assets';\n  const APP_FOLDER = 'app'; // This is used to add or remove EJSON from the beginning of everything nested\n  // inside an EJSON custom type. It should only be called on pure JSON!\n\n  var replaceNames = function (filter, thing) {\n    if (typeof thing === \"object\" && thing !== null) {\n      if (_.isArray(thing)) {\n        return _.map(thing, _.bind(replaceNames, null, filter));\n      }\n\n      var ret = {};\n\n      _.each(thing, function (value, key) {\n        ret[filter(key)] = replaceNames(filter, value);\n      });\n\n      return ret;\n    }\n\n    return thing;\n  }; // Ensure that EJSON.clone keeps a Timestamp as a Timestamp (instead of just\n  // doing a structural clone).\n  // XXX how ok is this? what if there are multiple copies of MongoDB loaded?\n\n\n  MongoDB.Timestamp.prototype.clone = function () {\n    // Timestamps should be immutable.\n    return this;\n  };\n\n  var makeMongoLegal = function (name) {\n    return \"EJSON\" + name;\n  };\n\n  var unmakeMongoLegal = function (name) {\n    return name.substr(5);\n  };\n\n  var replaceMongoAtomWithMeteor = function (document) {\n    if (document instanceof MongoDB.Binary) {\n      var buffer = document.value(true);\n      return new Uint8Array(buffer);\n    }\n\n    if (document instanceof MongoDB.ObjectID) {\n      return new Mongo.ObjectID(document.toHexString());\n    }\n\n    if (document instanceof MongoDB.Decimal128) {\n      return Decimal(document.toString());\n    }\n\n    if (document[\"EJSON$type\"] && document[\"EJSON$value\"] && _.size(document) === 2) {\n      return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document));\n    }\n\n    if (document instanceof MongoDB.Timestamp) {\n      // For now, the Meteor representation of a Mongo timestamp type (not a date!\n      // this is a weird internal thing used in the oplog!) is the same as the\n      // Mongo representation. We need to do this explicitly or else we would do a\n      // structural clone and lose the prototype.\n      return document;\n    }\n\n    return undefined;\n  };\n\n  var replaceMeteorAtomWithMongo = function (document) {\n    if (EJSON.isBinary(document)) {\n      // This does more copies than we'd like, but is necessary because\n      // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually\n      // serialize it correctly).\n      return new MongoDB.Binary(Buffer.from(document));\n    }\n\n    if (document instanceof Mongo.ObjectID) {\n      return new MongoDB.ObjectID(document.toHexString());\n    }\n\n    if (document instanceof MongoDB.Timestamp) {\n      // For now, the Meteor representation of a Mongo timestamp type (not a date!\n      // this is a weird internal thing used in the oplog!) is the same as the\n      // Mongo representation. We need to do this explicitly or else we would do a\n      // structural clone and lose the prototype.\n      return document;\n    }\n\n    if (document instanceof Decimal) {\n      return MongoDB.Decimal128.fromString(document.toString());\n    }\n\n    if (EJSON._isCustomType(document)) {\n      return replaceNames(makeMongoLegal, EJSON.toJSONValue(document));\n    } // It is not ordinarily possible to stick dollar-sign keys into mongo\n    // so we don't bother checking for things that need escaping at this time.\n\n\n    return undefined;\n  };\n\n  var replaceTypes = function (document, atomTransformer) {\n    if (typeof document !== 'object' || document === null) return document;\n    var replacedTopLevelAtom = atomTransformer(document);\n    if (replacedTopLevelAtom !== undefined) return replacedTopLevelAtom;\n    var ret = document;\n\n    _.each(document, function (val, key) {\n      var valReplaced = replaceTypes(val, atomTransformer);\n\n      if (val !== valReplaced) {\n        // Lazy clone. Shallow copy.\n        if (ret === document) ret = _.clone(document);\n        ret[key] = valReplaced;\n      }\n    });\n\n    return ret;\n  };\n\n  MongoConnection = function (url, options) {\n    var _Meteor$settings, _Meteor$settings$pack, _Meteor$settings$pack2;\n\n    var self = this;\n    options = options || {};\n    self._observeMultiplexers = {};\n    self._onFailoverHook = new Hook();\n\n    const userOptions = _objectSpread(_objectSpread({}, Mongo._connectionOptions || {}), ((_Meteor$settings = Meteor.settings) === null || _Meteor$settings === void 0 ? void 0 : (_Meteor$settings$pack = _Meteor$settings.packages) === null || _Meteor$settings$pack === void 0 ? void 0 : (_Meteor$settings$pack2 = _Meteor$settings$pack.mongo) === null || _Meteor$settings$pack2 === void 0 ? void 0 : _Meteor$settings$pack2.options) || {});\n\n    var mongoOptions = Object.assign({\n      ignoreUndefined: true\n    }, userOptions); // Internally the oplog connections specify their own maxPoolSize\n    // which we don't want to overwrite with any user defined value\n\n    if (_.has(options, 'maxPoolSize')) {\n      // If we just set this for \"server\", replSet will override it. If we just\n      // set it for replSet, it will be ignored if we're not using a replSet.\n      mongoOptions.maxPoolSize = options.maxPoolSize;\n    } // Transform options like \"tlsCAFileAsset\": \"filename.pem\" into\n    // \"tlsCAFile\": \"/<fullpath>/filename.pem\"\n\n\n    Object.entries(mongoOptions || {}).filter(_ref => {\n      let [key] = _ref;\n      return key && key.endsWith(FILE_ASSET_SUFFIX);\n    }).forEach(_ref2 => {\n      let [key, value] = _ref2;\n      const optionName = key.replace(FILE_ASSET_SUFFIX, '');\n      mongoOptions[optionName] = path.join(Assets.getServerDir(), ASSETS_FOLDER, APP_FOLDER, value);\n      delete mongoOptions[key];\n    });\n    self.db = null; // We keep track of the ReplSet's primary, so that we can trigger hooks when\n    // it changes.  The Node driver's joined callback seems to fire way too\n    // often, which is why we need to track it ourselves.\n\n    self._primary = null;\n    self._oplogHandle = null;\n    self._docFetcher = null;\n    var connectFuture = new Future();\n    new MongoDB.MongoClient(url, mongoOptions).connect(Meteor.bindEnvironment(function (err, client) {\n      if (err) {\n        throw err;\n      }\n\n      var db = client.db();\n\n      try {\n        const helloDocument = db.admin().command({\n          hello: 1\n        }).await(); // First, figure out what the current primary is, if any.\n\n        if (helloDocument.primary) {\n          self._primary = helloDocument.primary;\n        }\n      } catch (_) {\n        // ismaster command is supported on older mongodb versions\n        const isMasterDocument = db.admin().command({\n          ismaster: 1\n        }).await(); // First, figure out what the current primary is, if any.\n\n        if (isMasterDocument.primary) {\n          self._primary = isMasterDocument.primary;\n        }\n      }\n\n      client.topology.on('joined', Meteor.bindEnvironment(function (kind, doc) {\n        if (kind === 'primary') {\n          if (doc.primary !== self._primary) {\n            self._primary = doc.primary;\n\n            self._onFailoverHook.each(function (callback) {\n              callback();\n              return true;\n            });\n          }\n        } else if (doc.me === self._primary) {\n          // The thing we thought was primary is now something other than\n          // primary.  Forget that we thought it was primary.  (This means\n          // that if a server stops being primary and then starts being\n          // primary again without another server becoming primary in the\n          // middle, we'll correctly count it as a failover.)\n          self._primary = null;\n        }\n      })); // Allow the constructor to return.\n\n      connectFuture['return']({\n        client,\n        db\n      });\n    }, connectFuture.resolver() // onException\n    )); // Wait for the connection to be successful (throws on failure) and assign the\n    // results (`client` and `db`) to `self`.\n\n    Object.assign(self, connectFuture.wait());\n\n    if (options.oplogUrl && !Package['disable-oplog']) {\n      self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName);\n      self._docFetcher = new DocFetcher(self);\n    }\n  };\n\n  MongoConnection.prototype.close = function () {\n    var self = this;\n    if (!self.db) throw Error(\"close called before Connection created?\"); // XXX probably untested\n\n    var oplogHandle = self._oplogHandle;\n    self._oplogHandle = null;\n    if (oplogHandle) oplogHandle.stop(); // Use Future.wrap so that errors get thrown. This happens to\n    // work even outside a fiber since the 'close' method is not\n    // actually asynchronous.\n\n    Future.wrap(_.bind(self.client.close, self.client))(true).wait();\n  }; // Returns the Mongo Collection object; may yield.\n\n\n  MongoConnection.prototype.rawCollection = function (collectionName) {\n    var self = this;\n    if (!self.db) throw Error(\"rawCollection called before Connection created?\");\n    return self.db.collection(collectionName);\n  };\n\n  MongoConnection.prototype._createCappedCollection = function (collectionName, byteSize, maxDocuments) {\n    var self = this;\n    if (!self.db) throw Error(\"_createCappedCollection called before Connection created?\");\n    var future = new Future();\n    self.db.createCollection(collectionName, {\n      capped: true,\n      size: byteSize,\n      max: maxDocuments\n    }, future.resolver());\n    future.wait();\n  }; // This should be called synchronously with a write, to create a\n  // transaction on the current write fence, if any. After we can read\n  // the write, and after observers have been notified (or at least,\n  // after the observer notifiers have added themselves to the write\n  // fence), you should call 'committed()' on the object returned.\n\n\n  MongoConnection.prototype._maybeBeginWrite = function () {\n    var fence = DDPServer._CurrentWriteFence.get();\n\n    if (fence) {\n      return fence.beginWrite();\n    } else {\n      return {\n        committed: function () {}\n      };\n    }\n  }; // Internal interface: adds a callback which is called when the Mongo primary\n  // changes. Returns a stop handle.\n\n\n  MongoConnection.prototype._onFailover = function (callback) {\n    return this._onFailoverHook.register(callback);\n  }; //////////// Public API //////////\n  // The write methods block until the database has confirmed the write (it may\n  // not be replicated or stable on disk, but one server has confirmed it) if no\n  // callback is provided. If a callback is provided, then they call the callback\n  // when the write is confirmed. They return nothing on success, and raise an\n  // exception on failure.\n  //\n  // After making a write (with insert, update, remove), observers are\n  // notified asynchronously. If you want to receive a callback once all\n  // of the observer notifications have landed for your write, do the\n  // writes inside a write fence (set DDPServer._CurrentWriteFence to a new\n  // _WriteFence, and then set a callback on the write fence.)\n  //\n  // Since our execution environment is single-threaded, this is\n  // well-defined -- a write \"has been made\" if it's returned, and an\n  // observer \"has been notified\" if its callback has returned.\n\n\n  var writeCallback = function (write, refresh, callback) {\n    return function (err, result) {\n      if (!err) {\n        // XXX We don't have to run this on error, right?\n        try {\n          refresh();\n        } catch (refreshErr) {\n          if (callback) {\n            callback(refreshErr);\n            return;\n          } else {\n            throw refreshErr;\n          }\n        }\n      }\n\n      write.committed();\n\n      if (callback) {\n        callback(err, result);\n      } else if (err) {\n        throw err;\n      }\n    };\n  };\n\n  var bindEnvironmentForWrite = function (callback) {\n    return Meteor.bindEnvironment(callback, \"Mongo write\");\n  };\n\n  MongoConnection.prototype._insert = function (collection_name, document, callback) {\n    var self = this;\n\n    var sendError = function (e) {\n      if (callback) return callback(e);\n      throw e;\n    };\n\n    if (collection_name === \"___meteor_failure_test_collection\") {\n      var e = new Error(\"Failure test\");\n      e._expectedByTest = true;\n      sendError(e);\n      return;\n    }\n\n    if (!(LocalCollection._isPlainObject(document) && !EJSON._isCustomType(document))) {\n      sendError(new Error(\"Only plain objects may be inserted into MongoDB\"));\n      return;\n    }\n\n    var write = self._maybeBeginWrite();\n\n    var refresh = function () {\n      Meteor.refresh({\n        collection: collection_name,\n        id: document._id\n      });\n    };\n\n    callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n\n    try {\n      var collection = self.rawCollection(collection_name);\n      collection.insertOne(replaceTypes(document, replaceMeteorAtomWithMongo), {\n        safe: true\n      }).then(_ref3 => {\n        let {\n          insertedId\n        } = _ref3;\n        callback(null, insertedId);\n      }).catch(e => {\n        callback(e, null);\n      });\n    } catch (err) {\n      write.committed();\n      throw err;\n    }\n  }; // Cause queries that may be affected by the selector to poll in this write\n  // fence.\n\n\n  MongoConnection.prototype._refresh = function (collectionName, selector) {\n    var refreshKey = {\n      collection: collectionName\n    }; // If we know which documents we're removing, don't poll queries that are\n    // specific to other documents. (Note that multiple notifications here should\n    // not cause multiple polls, since all our listener is doing is enqueueing a\n    // poll.)\n\n    var specificIds = LocalCollection._idsMatchedBySelector(selector);\n\n    if (specificIds) {\n      _.each(specificIds, function (id) {\n        Meteor.refresh(_.extend({\n          id: id\n        }, refreshKey));\n      });\n    } else {\n      Meteor.refresh(refreshKey);\n    }\n  };\n\n  MongoConnection.prototype._remove = function (collection_name, selector, callback) {\n    var self = this;\n\n    if (collection_name === \"___meteor_failure_test_collection\") {\n      var e = new Error(\"Failure test\");\n      e._expectedByTest = true;\n\n      if (callback) {\n        return callback(e);\n      } else {\n        throw e;\n      }\n    }\n\n    var write = self._maybeBeginWrite();\n\n    var refresh = function () {\n      self._refresh(collection_name, selector);\n    };\n\n    callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n\n    try {\n      var collection = self.rawCollection(collection_name);\n      collection.deleteMany(replaceTypes(selector, replaceMeteorAtomWithMongo), {\n        safe: true\n      }).then(_ref4 => {\n        let {\n          deletedCount\n        } = _ref4;\n        callback(null, transformResult({\n          result: {\n            modifiedCount: deletedCount\n          }\n        }).numberAffected);\n      }).catch(err => {\n        callback(err);\n      });\n    } catch (err) {\n      write.committed();\n      throw err;\n    }\n  };\n\n  MongoConnection.prototype._dropCollection = function (collectionName, cb) {\n    var self = this;\n\n    var write = self._maybeBeginWrite();\n\n    var refresh = function () {\n      Meteor.refresh({\n        collection: collectionName,\n        id: null,\n        dropCollection: true\n      });\n    };\n\n    cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n\n    try {\n      var collection = self.rawCollection(collectionName);\n      collection.drop(cb);\n    } catch (e) {\n      write.committed();\n      throw e;\n    }\n  }; // For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`\n  // because it lets the test's fence wait for it to be complete.\n\n\n  MongoConnection.prototype._dropDatabase = function (cb) {\n    var self = this;\n\n    var write = self._maybeBeginWrite();\n\n    var refresh = function () {\n      Meteor.refresh({\n        dropDatabase: true\n      });\n    };\n\n    cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n\n    try {\n      self.db.dropDatabase(cb);\n    } catch (e) {\n      write.committed();\n      throw e;\n    }\n  };\n\n  MongoConnection.prototype._update = function (collection_name, selector, mod, options, callback) {\n    var self = this;\n\n    if (!callback && options instanceof Function) {\n      callback = options;\n      options = null;\n    }\n\n    if (collection_name === \"___meteor_failure_test_collection\") {\n      var e = new Error(\"Failure test\");\n      e._expectedByTest = true;\n\n      if (callback) {\n        return callback(e);\n      } else {\n        throw e;\n      }\n    } // explicit safety check. null and undefined can crash the mongo\n    // driver. Although the node driver and minimongo do 'support'\n    // non-object modifier in that they don't crash, they are not\n    // meaningful operations and do not do anything. Defensively throw an\n    // error here.\n\n\n    if (!mod || typeof mod !== 'object') throw new Error(\"Invalid modifier. Modifier must be an object.\");\n\n    if (!(LocalCollection._isPlainObject(mod) && !EJSON._isCustomType(mod))) {\n      throw new Error(\"Only plain objects may be used as replacement\" + \" documents in MongoDB\");\n    }\n\n    if (!options) options = {};\n\n    var write = self._maybeBeginWrite();\n\n    var refresh = function () {\n      self._refresh(collection_name, selector);\n    };\n\n    callback = writeCallback(write, refresh, callback);\n\n    try {\n      var collection = self.rawCollection(collection_name);\n      var mongoOpts = {\n        safe: true\n      }; // Add support for filtered positional operator\n\n      if (options.arrayFilters !== undefined) mongoOpts.arrayFilters = options.arrayFilters; // explictly enumerate options that minimongo supports\n\n      if (options.upsert) mongoOpts.upsert = true;\n      if (options.multi) mongoOpts.multi = true; // Lets you get a more more full result from MongoDB. Use with caution:\n      // might not work with C.upsert (as opposed to C.update({upsert:true}) or\n      // with simulated upsert.\n\n      if (options.fullResult) mongoOpts.fullResult = true;\n      var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo);\n      var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo);\n\n      var isModify = LocalCollection._isModificationMod(mongoMod);\n\n      if (options._forbidReplace && !isModify) {\n        var err = new Error(\"Invalid modifier. Replacements are forbidden.\");\n\n        if (callback) {\n          return callback(err);\n        } else {\n          throw err;\n        }\n      } // We've already run replaceTypes/replaceMeteorAtomWithMongo on\n      // selector and mod.  We assume it doesn't matter, as far as\n      // the behavior of modifiers is concerned, whether `_modify`\n      // is run on EJSON or on mongo-converted EJSON.\n      // Run this code up front so that it fails fast if someone uses\n      // a Mongo update operator we don't support.\n\n\n      let knownId;\n\n      if (options.upsert) {\n        try {\n          let newDoc = LocalCollection._createUpsertDocument(selector, mod);\n\n          knownId = newDoc._id;\n        } catch (err) {\n          if (callback) {\n            return callback(err);\n          } else {\n            throw err;\n          }\n        }\n      }\n\n      if (options.upsert && !isModify && !knownId && options.insertedId && !(options.insertedId instanceof Mongo.ObjectID && options.generatedId)) {\n        // In case of an upsert with a replacement, where there is no _id defined\n        // in either the query or the replacement doc, mongo will generate an id itself.\n        // Therefore we need this special strategy if we want to control the id ourselves.\n        // We don't need to do this when:\n        // - This is not a replacement, so we can add an _id to $setOnInsert\n        // - The id is defined by query or mod we can just add it to the replacement doc\n        // - The user did not specify any id preference and the id is a Mongo ObjectId,\n        //     then we can just let Mongo generate the id\n        simulateUpsertWithInsertedId(collection, mongoSelector, mongoMod, options, // This callback does not need to be bindEnvironment'ed because\n        // simulateUpsertWithInsertedId() wraps it and then passes it through\n        // bindEnvironmentForWrite.\n        function (error, result) {\n          // If we got here via a upsert() call, then options._returnObject will\n          // be set and we should return the whole object. Otherwise, we should\n          // just return the number of affected docs to match the mongo API.\n          if (result && !options._returnObject) {\n            callback(error, result.numberAffected);\n          } else {\n            callback(error, result);\n          }\n        });\n      } else {\n        if (options.upsert && !knownId && options.insertedId && isModify) {\n          if (!mongoMod.hasOwnProperty('$setOnInsert')) {\n            mongoMod.$setOnInsert = {};\n          }\n\n          knownId = options.insertedId;\n          Object.assign(mongoMod.$setOnInsert, replaceTypes({\n            _id: options.insertedId\n          }, replaceMeteorAtomWithMongo));\n        }\n\n        const strings = Object.keys(mongoMod).filter(key => !key.startsWith(\"$\"));\n        let updateMethod = strings.length > 0 ? 'replaceOne' : 'updateMany';\n        updateMethod = updateMethod === 'updateMany' && !mongoOpts.multi ? 'updateOne' : updateMethod;\n        collection[updateMethod].bind(collection)(mongoSelector, mongoMod, mongoOpts, // mongo driver now returns undefined for err in the callback\n        bindEnvironmentForWrite(function () {\n          let err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n          let result = arguments.length > 1 ? arguments[1] : undefined;\n\n          if (!err) {\n            var meteorResult = transformResult({\n              result\n            });\n\n            if (meteorResult && options._returnObject) {\n              // If this was an upsert() call, and we ended up\n              // inserting a new doc and we know its id, then\n              // return that id as well.\n              if (options.upsert && meteorResult.insertedId) {\n                if (knownId) {\n                  meteorResult.insertedId = knownId;\n                } else if (meteorResult.insertedId instanceof MongoDB.ObjectID) {\n                  meteorResult.insertedId = new Mongo.ObjectID(meteorResult.insertedId.toHexString());\n                }\n              }\n\n              callback(err, meteorResult);\n            } else {\n              callback(err, meteorResult.numberAffected);\n            }\n          } else {\n            callback(err);\n          }\n        }));\n      }\n    } catch (e) {\n      write.committed();\n      throw e;\n    }\n  };\n\n  var transformResult = function (driverResult) {\n    var meteorResult = {\n      numberAffected: 0\n    };\n\n    if (driverResult) {\n      var mongoResult = driverResult.result; // On updates with upsert:true, the inserted values come as a list of\n      // upserted values -- even with options.multi, when the upsert does insert,\n      // it only inserts one element.\n\n      if (mongoResult.upsertedCount) {\n        meteorResult.numberAffected = mongoResult.upsertedCount;\n\n        if (mongoResult.upsertedId) {\n          meteorResult.insertedId = mongoResult.upsertedId;\n        }\n      } else {\n        // n was used before Mongo 5.0, in Mongo 5.0 we are not receiving this n\n        // field and so we are using modifiedCount instead\n        meteorResult.numberAffected = mongoResult.n || mongoResult.matchedCount || mongoResult.modifiedCount;\n      }\n    }\n\n    return meteorResult;\n  };\n\n  var NUM_OPTIMISTIC_TRIES = 3; // exposed for testing\n\n  MongoConnection._isCannotChangeIdError = function (err) {\n    // Mongo 3.2.* returns error as next Object:\n    // {name: String, code: Number, errmsg: String}\n    // Older Mongo returns:\n    // {name: String, code: Number, err: String}\n    var error = err.errmsg || err.err; // We don't use the error code here\n    // because the error code we observed it producing (16837) appears to be\n    // a far more generic error code based on examining the source.\n\n    if (error.indexOf('The _id field cannot be changed') === 0 || error.indexOf(\"the (immutable) field '_id' was found to have been altered to _id\") !== -1) {\n      return true;\n    }\n\n    return false;\n  };\n\n  var simulateUpsertWithInsertedId = function (collection, selector, mod, options, callback) {\n    // STRATEGY: First try doing an upsert with a generated ID.\n    // If this throws an error about changing the ID on an existing document\n    // then without affecting the database, we know we should probably try\n    // an update without the generated ID. If it affected 0 documents,\n    // then without affecting the database, we the document that first\n    // gave the error is probably removed and we need to try an insert again\n    // We go back to step one and repeat.\n    // Like all \"optimistic write\" schemes, we rely on the fact that it's\n    // unlikely our writes will continue to be interfered with under normal\n    // circumstances (though sufficiently heavy contention with writers\n    // disagreeing on the existence of an object will cause writes to fail\n    // in theory).\n    var insertedId = options.insertedId; // must exist\n\n    var mongoOptsForUpdate = {\n      safe: true,\n      multi: options.multi\n    };\n    var mongoOptsForInsert = {\n      safe: true,\n      upsert: true\n    };\n    var replacementWithId = Object.assign(replaceTypes({\n      _id: insertedId\n    }, replaceMeteorAtomWithMongo), mod);\n    var tries = NUM_OPTIMISTIC_TRIES;\n\n    var doUpdate = function () {\n      tries--;\n\n      if (!tries) {\n        callback(new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\"));\n      } else {\n        let method = collection.updateMany;\n\n        if (!Object.keys(mod).some(key => key.startsWith(\"$\"))) {\n          method = collection.replaceOne.bind(collection);\n        }\n\n        method(selector, mod, mongoOptsForUpdate, bindEnvironmentForWrite(function (err, result) {\n          if (err) {\n            callback(err);\n          } else if (result && (result.modifiedCount || result.upsertedCount)) {\n            callback(null, {\n              numberAffected: result.modifiedCount || result.upsertedCount,\n              insertedId: result.upsertedId || undefined\n            });\n          } else {\n            doConditionalInsert();\n          }\n        }));\n      }\n    };\n\n    var doConditionalInsert = function () {\n      collection.replaceOne(selector, replacementWithId, mongoOptsForInsert, bindEnvironmentForWrite(function (err, result) {\n        if (err) {\n          // figure out if this is a\n          // \"cannot change _id of document\" error, and\n          // if so, try doUpdate() again, up to 3 times.\n          if (MongoConnection._isCannotChangeIdError(err)) {\n            doUpdate();\n          } else {\n            callback(err);\n          }\n        } else {\n          callback(null, {\n            numberAffected: result.upsertedCount,\n            insertedId: result.upsertedId\n          });\n        }\n      }));\n    };\n\n    doUpdate();\n  };\n\n  _.each([\"insert\", \"update\", \"remove\", \"dropCollection\", \"dropDatabase\"], function (method) {\n    MongoConnection.prototype[method] = function\n      /* arguments */\n    () {\n      var self = this;\n      return Meteor.wrapAsync(self[\"_\" + method]).apply(self, arguments);\n    };\n  }); // XXX MongoConnection.upsert() does not return the id of the inserted document\n  // unless you set it explicitly in the selector or modifier (as a replacement\n  // doc).\n\n\n  MongoConnection.prototype.upsert = function (collectionName, selector, mod, options, callback) {\n    var self = this;\n\n    if (typeof options === \"function\" && !callback) {\n      callback = options;\n      options = {};\n    }\n\n    return self.update(collectionName, selector, mod, _.extend({}, options, {\n      upsert: true,\n      _returnObject: true\n    }), callback);\n  };\n\n  MongoConnection.prototype.find = function (collectionName, selector, options) {\n    var self = this;\n    if (arguments.length === 1) selector = {};\n    return new Cursor(self, new CursorDescription(collectionName, selector, options));\n  };\n\n  MongoConnection.prototype.findOne = function (collection_name, selector, options) {\n    var self = this;\n    if (arguments.length === 1) selector = {};\n    options = options || {};\n    options.limit = 1;\n    return self.find(collection_name, selector, options).fetch()[0];\n  }; // We'll actually design an index API later. For now, we just pass through to\n  // Mongo's, but make it synchronous.\n\n\n  MongoConnection.prototype.createIndex = function (collectionName, index, options) {\n    var self = this; // We expect this function to be called at startup, not from within a method,\n    // so we don't interact with the write fence.\n\n    var collection = self.rawCollection(collectionName);\n    var future = new Future();\n    var indexName = collection.createIndex(index, options, future.resolver());\n    future.wait();\n  };\n\n  MongoConnection.prototype._ensureIndex = MongoConnection.prototype.createIndex;\n\n  MongoConnection.prototype._dropIndex = function (collectionName, index) {\n    var self = this; // This function is only used by test code, not within a method, so we don't\n    // interact with the write fence.\n\n    var collection = self.rawCollection(collectionName);\n    var future = new Future();\n    var indexName = collection.dropIndex(index, future.resolver());\n    future.wait();\n  }; // CURSORS\n  // There are several classes which relate to cursors:\n  //\n  // CursorDescription represents the arguments used to construct a cursor:\n  // collectionName, selector, and (find) options.  Because it is used as a key\n  // for cursor de-dup, everything in it should either be JSON-stringifiable or\n  // not affect observeChanges output (eg, options.transform functions are not\n  // stringifiable but do not affect observeChanges).\n  //\n  // SynchronousCursor is a wrapper around a MongoDB cursor\n  // which includes fully-synchronous versions of forEach, etc.\n  //\n  // Cursor is the cursor object returned from find(), which implements the\n  // documented Mongo.Collection cursor API.  It wraps a CursorDescription and a\n  // SynchronousCursor (lazily: it doesn't contact Mongo until you call a method\n  // like fetch or forEach on it).\n  //\n  // ObserveHandle is the \"observe handle\" returned from observeChanges. It has a\n  // reference to an ObserveMultiplexer.\n  //\n  // ObserveMultiplexer allows multiple identical ObserveHandles to be driven by a\n  // single observe driver.\n  //\n  // There are two \"observe drivers\" which drive ObserveMultiplexers:\n  //   - PollingObserveDriver caches the results of a query and reruns it when\n  //     necessary.\n  //   - OplogObserveDriver follows the Mongo operation log to directly observe\n  //     database changes.\n  // Both implementations follow the same simple interface: when you create them,\n  // they start sending observeChanges callbacks (and a ready() invocation) to\n  // their ObserveMultiplexer, and you stop them by calling their stop() method.\n\n\n  CursorDescription = function (collectionName, selector, options) {\n    var self = this;\n    self.collectionName = collectionName;\n    self.selector = Mongo.Collection._rewriteSelector(selector);\n    self.options = options || {};\n  };\n\n  Cursor = function (mongo, cursorDescription) {\n    var self = this;\n    self._mongo = mongo;\n    self._cursorDescription = cursorDescription;\n    self._synchronousCursor = null;\n  };\n\n  _.each(['forEach', 'map', 'fetch', 'count', Symbol.iterator], function (method) {\n    Cursor.prototype[method] = function () {\n      var self = this; // You can only observe a tailable cursor.\n\n      if (self._cursorDescription.options.tailable) throw new Error(\"Cannot call \" + method + \" on a tailable cursor\");\n\n      if (!self._synchronousCursor) {\n        self._synchronousCursor = self._mongo._createSynchronousCursor(self._cursorDescription, {\n          // Make sure that the \"self\" argument to forEach/map callbacks is the\n          // Cursor, not the SynchronousCursor.\n          selfForIteration: self,\n          useTransform: true\n        });\n      }\n\n      return self._synchronousCursor[method].apply(self._synchronousCursor, arguments);\n    };\n  });\n\n  Cursor.prototype.getTransform = function () {\n    return this._cursorDescription.options.transform;\n  }; // When you call Meteor.publish() with a function that returns a Cursor, we need\n  // to transmute it into the equivalent subscription.  This is the function that\n  // does that.\n\n\n  Cursor.prototype._publishCursor = function (sub) {\n    var self = this;\n    var collection = self._cursorDescription.collectionName;\n    return Mongo.Collection._publishCursor(self, sub, collection);\n  }; // Used to guarantee that publish functions return at most one cursor per\n  // collection. Private, because we might later have cursors that include\n  // documents from multiple collections somehow.\n\n\n  Cursor.prototype._getCollectionName = function () {\n    var self = this;\n    return self._cursorDescription.collectionName;\n  };\n\n  Cursor.prototype.observe = function (callbacks) {\n    var self = this;\n    return LocalCollection._observeFromObserveChanges(self, callbacks);\n  };\n\n  Cursor.prototype.observeChanges = function (callbacks) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var self = this;\n    var methods = ['addedAt', 'added', 'changedAt', 'changed', 'removedAt', 'removed', 'movedTo'];\n\n    var ordered = LocalCollection._observeChangesCallbacksAreOrdered(callbacks);\n\n    let exceptionName = callbacks._fromObserve ? 'observe' : 'observeChanges';\n    exceptionName += ' callback';\n    methods.forEach(function (method) {\n      if (callbacks[method] && typeof callbacks[method] == \"function\") {\n        callbacks[method] = Meteor.bindEnvironment(callbacks[method], method + exceptionName);\n      }\n    });\n    return self._mongo._observeChanges(self._cursorDescription, ordered, callbacks, options.nonMutatingCallbacks);\n  };\n\n  MongoConnection.prototype._createSynchronousCursor = function (cursorDescription, options) {\n    var self = this;\n    options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n    var collection = self.rawCollection(cursorDescription.collectionName);\n    var cursorOptions = cursorDescription.options;\n    var mongoOptions = {\n      sort: cursorOptions.sort,\n      limit: cursorOptions.limit,\n      skip: cursorOptions.skip,\n      projection: cursorOptions.fields || cursorOptions.projection,\n      readPreference: cursorOptions.readPreference\n    }; // Do we want a tailable cursor (which only works on capped collections)?\n\n    if (cursorOptions.tailable) {\n      mongoOptions.numberOfRetries = -1;\n    }\n\n    var dbCursor = collection.find(replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo), mongoOptions); // Do we want a tailable cursor (which only works on capped collections)?\n\n    if (cursorOptions.tailable) {\n      // We want a tailable cursor...\n      dbCursor.addCursorFlag(\"tailable\", true); // ... and for the server to wait a bit if any getMore has no data (rather\n      // than making us put the relevant sleeps in the client)...\n\n      dbCursor.addCursorFlag(\"awaitData\", true); // And if this is on the oplog collection and the cursor specifies a 'ts',\n      // then set the undocumented oplog replay flag, which does a special scan to\n      // find the first document (instead of creating an index on ts). This is a\n      // very hard-coded Mongo flag which only works on the oplog collection and\n      // only works with the ts field.\n\n      if (cursorDescription.collectionName === OPLOG_COLLECTION && cursorDescription.selector.ts) {\n        dbCursor.addCursorFlag(\"oplogReplay\", true);\n      }\n    }\n\n    if (typeof cursorOptions.maxTimeMs !== 'undefined') {\n      dbCursor = dbCursor.maxTimeMS(cursorOptions.maxTimeMs);\n    }\n\n    if (typeof cursorOptions.hint !== 'undefined') {\n      dbCursor = dbCursor.hint(cursorOptions.hint);\n    }\n\n    return new SynchronousCursor(dbCursor, cursorDescription, options);\n  };\n\n  var SynchronousCursor = function (dbCursor, cursorDescription, options) {\n    var self = this;\n    options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n    self._dbCursor = dbCursor;\n    self._cursorDescription = cursorDescription; // The \"self\" argument passed to forEach/map callbacks. If we're wrapped\n    // inside a user-visible Cursor, we want to provide the outer cursor!\n\n    self._selfForIteration = options.selfForIteration || self;\n\n    if (options.useTransform && cursorDescription.options.transform) {\n      self._transform = LocalCollection.wrapTransform(cursorDescription.options.transform);\n    } else {\n      self._transform = null;\n    }\n\n    self._synchronousCount = Future.wrap(dbCursor.count.bind(dbCursor));\n    self._visitedIds = new LocalCollection._IdMap();\n  };\n\n  _.extend(SynchronousCursor.prototype, {\n    // Returns a Promise for the next object from the underlying cursor (before\n    // the Mongo->Meteor type replacement).\n    _rawNextObjectPromise: function () {\n      const self = this;\n      return new Promise((resolve, reject) => {\n        self._dbCursor.next((err, doc) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(doc);\n          }\n        });\n      });\n    },\n    // Returns a Promise for the next object from the cursor, skipping those whose\n    // IDs we've already seen and replacing Mongo atoms with Meteor atoms.\n    _nextObjectPromise: function () {\n      return Promise.asyncApply(() => {\n        var self = this;\n\n        while (true) {\n          var doc = Promise.await(self._rawNextObjectPromise());\n          if (!doc) return null;\n          doc = replaceTypes(doc, replaceMongoAtomWithMeteor);\n\n          if (!self._cursorDescription.options.tailable && _.has(doc, '_id')) {\n            // Did Mongo give us duplicate documents in the same cursor? If so,\n            // ignore this one. (Do this before the transform, since transform might\n            // return some unrelated value.) We don't do this for tailable cursors,\n            // because we want to maintain O(1) memory usage. And if there isn't _id\n            // for some reason (maybe it's the oplog), then we don't do this either.\n            // (Be careful to do this for falsey but existing _id, though.)\n            if (self._visitedIds.has(doc._id)) continue;\n\n            self._visitedIds.set(doc._id, true);\n          }\n\n          if (self._transform) doc = self._transform(doc);\n          return doc;\n        }\n      });\n    },\n    // Returns a promise which is resolved with the next object (like with\n    // _nextObjectPromise) or rejected if the cursor doesn't return within\n    // timeoutMS ms.\n    _nextObjectPromiseWithTimeout: function (timeoutMS) {\n      const self = this;\n\n      if (!timeoutMS) {\n        return self._nextObjectPromise();\n      }\n\n      const nextObjectPromise = self._nextObjectPromise();\n\n      const timeoutErr = new Error('Client-side timeout waiting for next object');\n      const timeoutPromise = new Promise((resolve, reject) => {\n        const timer = setTimeout(() => {\n          reject(timeoutErr);\n        }, timeoutMS);\n      });\n      return Promise.race([nextObjectPromise, timeoutPromise]).catch(err => {\n        if (err === timeoutErr) {\n          self.close();\n        }\n\n        throw err;\n      });\n    },\n    _nextObject: function () {\n      var self = this;\n      return self._nextObjectPromise().await();\n    },\n    forEach: function (callback, thisArg) {\n      var self = this; // Get back to the beginning.\n\n      self._rewind(); // We implement the loop ourself instead of using self._dbCursor.each,\n      // because \"each\" will call its callback outside of a fiber which makes it\n      // much more complex to make this function synchronous.\n\n\n      var index = 0;\n\n      while (true) {\n        var doc = self._nextObject();\n\n        if (!doc) return;\n        callback.call(thisArg, doc, index++, self._selfForIteration);\n      }\n    },\n    // XXX Allow overlapping callback executions if callback yields.\n    map: function (callback, thisArg) {\n      var self = this;\n      var res = [];\n      self.forEach(function (doc, index) {\n        res.push(callback.call(thisArg, doc, index, self._selfForIteration));\n      });\n      return res;\n    },\n    _rewind: function () {\n      var self = this; // known to be synchronous\n\n      self._dbCursor.rewind();\n\n      self._visitedIds = new LocalCollection._IdMap();\n    },\n    // Mostly usable for tailable cursors.\n    close: function () {\n      var self = this;\n\n      self._dbCursor.close();\n    },\n    fetch: function () {\n      var self = this;\n      return self.map(_.identity);\n    },\n    count: function () {\n      var self = this;\n      return self._synchronousCount().wait();\n    },\n    // This method is NOT wrapped in Cursor.\n    getRawObjects: function (ordered) {\n      var self = this;\n\n      if (ordered) {\n        return self.fetch();\n      } else {\n        var results = new LocalCollection._IdMap();\n        self.forEach(function (doc) {\n          results.set(doc._id, doc);\n        });\n        return results;\n      }\n    }\n  });\n\n  SynchronousCursor.prototype[Symbol.iterator] = function () {\n    var self = this; // Get back to the beginning.\n\n    self._rewind();\n\n    return {\n      next() {\n        const doc = self._nextObject();\n\n        return doc ? {\n          value: doc\n        } : {\n          done: true\n        };\n      }\n\n    };\n  }; // Tails the cursor described by cursorDescription, most likely on the\n  // oplog. Calls docCallback with each document found. Ignores errors and just\n  // restarts the tail on error.\n  //\n  // If timeoutMS is set, then if we don't get a new document every timeoutMS,\n  // kill and restart the cursor. This is primarily a workaround for #8598.\n\n\n  MongoConnection.prototype.tail = function (cursorDescription, docCallback, timeoutMS) {\n    var self = this;\n    if (!cursorDescription.options.tailable) throw new Error(\"Can only tail a tailable cursor\");\n\n    var cursor = self._createSynchronousCursor(cursorDescription);\n\n    var stopped = false;\n    var lastTS;\n\n    var loop = function () {\n      var doc = null;\n\n      while (true) {\n        if (stopped) return;\n\n        try {\n          doc = cursor._nextObjectPromiseWithTimeout(timeoutMS).await();\n        } catch (err) {\n          // There's no good way to figure out if this was actually an error from\n          // Mongo, or just client-side (including our own timeout error). Ah\n          // well. But either way, we need to retry the cursor (unless the failure\n          // was because the observe got stopped).\n          doc = null;\n        } // Since we awaited a promise above, we need to check again to see if\n        // we've been stopped before calling the callback.\n\n\n        if (stopped) return;\n\n        if (doc) {\n          // If a tailable cursor contains a \"ts\" field, use it to recreate the\n          // cursor on error. (\"ts\" is a standard that Mongo uses internally for\n          // the oplog, and there's a special flag that lets you do binary search\n          // on it instead of needing to use an index.)\n          lastTS = doc.ts;\n          docCallback(doc);\n        } else {\n          var newSelector = _.clone(cursorDescription.selector);\n\n          if (lastTS) {\n            newSelector.ts = {\n              $gt: lastTS\n            };\n          }\n\n          cursor = self._createSynchronousCursor(new CursorDescription(cursorDescription.collectionName, newSelector, cursorDescription.options)); // Mongo failover takes many seconds.  Retry in a bit.  (Without this\n          // setTimeout, we peg the CPU at 100% and never notice the actual\n          // failover.\n\n          Meteor.setTimeout(loop, 100);\n          break;\n        }\n      }\n    };\n\n    Meteor.defer(loop);\n    return {\n      stop: function () {\n        stopped = true;\n        cursor.close();\n      }\n    };\n  };\n\n  MongoConnection.prototype._observeChanges = function (cursorDescription, ordered, callbacks, nonMutatingCallbacks) {\n    var self = this;\n\n    if (cursorDescription.options.tailable) {\n      return self._observeChangesTailable(cursorDescription, ordered, callbacks);\n    } // You may not filter out _id when observing changes, because the id is a core\n    // part of the observeChanges API.\n\n\n    const fieldsOptions = cursorDescription.options.projection || cursorDescription.options.fields;\n\n    if (fieldsOptions && (fieldsOptions._id === 0 || fieldsOptions._id === false)) {\n      throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n    }\n\n    var observeKey = EJSON.stringify(_.extend({\n      ordered: ordered\n    }, cursorDescription));\n    var multiplexer, observeDriver;\n    var firstHandle = false; // Find a matching ObserveMultiplexer, or create a new one. This next block is\n    // guaranteed to not yield (and it doesn't call anything that can observe a\n    // new query), so no other calls to this function can interleave with it.\n\n    Meteor._noYieldsAllowed(function () {\n      if (_.has(self._observeMultiplexers, observeKey)) {\n        multiplexer = self._observeMultiplexers[observeKey];\n      } else {\n        firstHandle = true; // Create a new ObserveMultiplexer.\n\n        multiplexer = new ObserveMultiplexer({\n          ordered: ordered,\n          onStop: function () {\n            delete self._observeMultiplexers[observeKey];\n            observeDriver.stop();\n          }\n        });\n        self._observeMultiplexers[observeKey] = multiplexer;\n      }\n    });\n\n    var observeHandle = new ObserveHandle(multiplexer, callbacks, nonMutatingCallbacks);\n\n    if (firstHandle) {\n      var matcher, sorter;\n\n      var canUseOplog = _.all([function () {\n        // At a bare minimum, using the oplog requires us to have an oplog, to\n        // want unordered callbacks, and to not want a callback on the polls\n        // that won't happen.\n        return self._oplogHandle && !ordered && !callbacks._testOnlyPollCallback;\n      }, function () {\n        // We need to be able to compile the selector. Fall back to polling for\n        // some newfangled $selector that minimongo doesn't support yet.\n        try {\n          matcher = new Minimongo.Matcher(cursorDescription.selector);\n          return true;\n        } catch (e) {\n          // XXX make all compilation errors MinimongoError or something\n          //     so that this doesn't ignore unrelated exceptions\n          return false;\n        }\n      }, function () {\n        // ... and the selector itself needs to support oplog.\n        return OplogObserveDriver.cursorSupported(cursorDescription, matcher);\n      }, function () {\n        // And we need to be able to compile the sort, if any.  eg, can't be\n        // {$natural: 1}.\n        if (!cursorDescription.options.sort) return true;\n\n        try {\n          sorter = new Minimongo.Sorter(cursorDescription.options.sort);\n          return true;\n        } catch (e) {\n          // XXX make all compilation errors MinimongoError or something\n          //     so that this doesn't ignore unrelated exceptions\n          return false;\n        }\n      }], function (f) {\n        return f();\n      }); // invoke each function\n\n\n      var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver;\n      observeDriver = new driverClass({\n        cursorDescription: cursorDescription,\n        mongoHandle: self,\n        multiplexer: multiplexer,\n        ordered: ordered,\n        matcher: matcher,\n        // ignored by polling\n        sorter: sorter,\n        // ignored by polling\n        _testOnlyPollCallback: callbacks._testOnlyPollCallback\n      }); // This field is only set for use in tests.\n\n      multiplexer._observeDriver = observeDriver;\n    } // Blocks until the initial adds have been sent.\n\n\n    multiplexer.addHandleAndSendInitialAdds(observeHandle);\n    return observeHandle;\n  }; // Listen for the invalidation messages that will trigger us to poll the\n  // database for changes. If this selector specifies specific IDs, specify them\n  // here, so that updates to different specific IDs don't cause us to poll.\n  // listenCallback is the same kind of (notification, complete) callback passed\n  // to InvalidationCrossbar.listen.\n\n\n  listenAll = function (cursorDescription, listenCallback) {\n    var listeners = [];\n    forEachTrigger(cursorDescription, function (trigger) {\n      listeners.push(DDPServer._InvalidationCrossbar.listen(trigger, listenCallback));\n    });\n    return {\n      stop: function () {\n        _.each(listeners, function (listener) {\n          listener.stop();\n        });\n      }\n    };\n  };\n\n  forEachTrigger = function (cursorDescription, triggerCallback) {\n    var key = {\n      collection: cursorDescription.collectionName\n    };\n\n    var specificIds = LocalCollection._idsMatchedBySelector(cursorDescription.selector);\n\n    if (specificIds) {\n      _.each(specificIds, function (id) {\n        triggerCallback(_.extend({\n          id: id\n        }, key));\n      });\n\n      triggerCallback(_.extend({\n        dropCollection: true,\n        id: null\n      }, key));\n    } else {\n      triggerCallback(key);\n    } // Everyone cares about the database being dropped.\n\n\n    triggerCallback({\n      dropDatabase: true\n    });\n  }; // observeChanges for tailable cursors on capped collections.\n  //\n  // Some differences from normal cursors:\n  //   - Will never produce anything other than 'added' or 'addedBefore'. If you\n  //     do update a document that has already been produced, this will not notice\n  //     it.\n  //   - If you disconnect and reconnect from Mongo, it will essentially restart\n  //     the query, which will lead to duplicate results. This is pretty bad,\n  //     but if you include a field called 'ts' which is inserted as\n  //     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the\n  //     current Mongo-style timestamp), we'll be able to find the place to\n  //     restart properly. (This field is specifically understood by Mongo with an\n  //     optimization which allows it to find the right place to start without\n  //     an index on ts. It's how the oplog works.)\n  //   - No callbacks are triggered synchronously with the call (there's no\n  //     differentiation between \"initial data\" and \"later changes\"; everything\n  //     that matches the query gets sent asynchronously).\n  //   - De-duplication is not implemented.\n  //   - Does not yet interact with the write fence. Probably, this should work by\n  //     ignoring removes (which don't work on capped collections) and updates\n  //     (which don't affect tailable cursors), and just keeping track of the ID\n  //     of the inserted object, and closing the write fence once you get to that\n  //     ID (or timestamp?).  This doesn't work well if the document doesn't match\n  //     the query, though.  On the other hand, the write fence can close\n  //     immediately if it does not match the query. So if we trust minimongo\n  //     enough to accurately evaluate the query against the write fence, we\n  //     should be able to do this...  Of course, minimongo doesn't even support\n  //     Mongo Timestamps yet.\n\n\n  MongoConnection.prototype._observeChangesTailable = function (cursorDescription, ordered, callbacks) {\n    var self = this; // Tailable cursors only ever call added/addedBefore callbacks, so it's an\n    // error if you didn't provide them.\n\n    if (ordered && !callbacks.addedBefore || !ordered && !callbacks.added) {\n      throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\") + \" tailable cursor without a \" + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n    }\n\n    return self.tail(cursorDescription, function (doc) {\n      var id = doc._id;\n      delete doc._id; // The ts is an implementation detail. Hide it.\n\n      delete doc.ts;\n\n      if (ordered) {\n        callbacks.addedBefore(id, doc, null);\n      } else {\n        callbacks.added(id, doc);\n      }\n    });\n  }; // XXX We probably need to find a better way to expose this. Right now\n  // it's only used by tests, but in fact you need it in normal\n  // operation to interact with capped collections.\n\n\n  MongoInternals.MongoTimestamp = MongoDB.Timestamp;\n  MongoInternals.Connection = MongoConnection;\n}.call(this, module);","map":{"version":3,"sources":["packages/mongo/mongo_driver.js"],"names":["_objectSpread","module1","link","default","v","normalizeProjection","DocFetcher","path","require","MongoDB","NpmModuleMongodb","Future","Npm","MongoInternals","NpmModules","mongodb","version","NpmModuleMongodbVersion","module","NpmModule","FILE_ASSET_SUFFIX","ASSETS_FOLDER","APP_FOLDER","replaceNames","filter","thing","_","isArray","map","bind","ret","each","value","key","Timestamp","prototype","clone","makeMongoLegal","name","unmakeMongoLegal","substr","replaceMongoAtomWithMeteor","document","Binary","buffer","Uint8Array","ObjectID","Mongo","toHexString","Decimal128","Decimal","toString","size","EJSON","fromJSONValue","undefined","replaceMeteorAtomWithMongo","isBinary","Buffer","from","fromString","_isCustomType","toJSONValue","replaceTypes","atomTransformer","replacedTopLevelAtom","val","valReplaced","MongoConnection","url","options","self","_observeMultiplexers","_onFailoverHook","Hook","userOptions","_connectionOptions","Meteor","settings","packages","mongo","mongoOptions","Object","assign","ignoreUndefined","has","maxPoolSize","entries","endsWith","forEach","optionName","replace","join","Assets","getServerDir","db","_primary","_oplogHandle","_docFetcher","connectFuture","MongoClient","connect","bindEnvironment","err","client","helloDocument","admin","command","hello","await","primary","isMasterDocument","ismaster","topology","on","kind","doc","callback","me","resolver","wait","oplogUrl","Package","OplogHandle","databaseName","close","Error","oplogHandle","stop","wrap","rawCollection","collectionName","collection","_createCappedCollection","byteSize","maxDocuments","future","createCollection","capped","max","_maybeBeginWrite","fence","DDPServer","_CurrentWriteFence","get","beginWrite","committed","_onFailover","register","writeCallback","write","refresh","result","refreshErr","bindEnvironmentForWrite","_insert","collection_name","sendError","e","_expectedByTest","LocalCollection","_isPlainObject","id","_id","insertOne","safe","then","insertedId","catch","_refresh","selector","refreshKey","specificIds","_idsMatchedBySelector","extend","_remove","deleteMany","deletedCount","transformResult","modifiedCount","numberAffected","_dropCollection","cb","dropCollection","drop","_dropDatabase","dropDatabase","_update","mod","Function","mongoOpts","arrayFilters","upsert","multi","fullResult","mongoSelector","mongoMod","isModify","_isModificationMod","_forbidReplace","knownId","newDoc","_createUpsertDocument","generatedId","simulateUpsertWithInsertedId","error","_returnObject","hasOwnProperty","$setOnInsert","strings","keys","startsWith","updateMethod","length","meteorResult","driverResult","mongoResult","upsertedCount","upsertedId","n","matchedCount","NUM_OPTIMISTIC_TRIES","_isCannotChangeIdError","errmsg","indexOf","mongoOptsForUpdate","mongoOptsForInsert","replacementWithId","tries","doUpdate","method","updateMany","some","replaceOne","doConditionalInsert","wrapAsync","apply","arguments","update","find","Cursor","CursorDescription","findOne","limit","fetch","createIndex","index","indexName","_ensureIndex","_dropIndex","dropIndex","Collection","_rewriteSelector","cursorDescription","_mongo","_cursorDescription","_synchronousCursor","Symbol","iterator","tailable","_createSynchronousCursor","selfForIteration","useTransform","getTransform","transform","_publishCursor","sub","_getCollectionName","observe","callbacks","_observeFromObserveChanges","observeChanges","methods","ordered","_observeChangesCallbacksAreOrdered","exceptionName","_fromObserve","_observeChanges","nonMutatingCallbacks","pick","cursorOptions","sort","skip","projection","fields","readPreference","numberOfRetries","dbCursor","addCursorFlag","OPLOG_COLLECTION","ts","maxTimeMs","maxTimeMS","hint","SynchronousCursor","_dbCursor","_selfForIteration","_transform","wrapTransform","_synchronousCount","count","_visitedIds","_IdMap","_rawNextObjectPromise","Promise","resolve","reject","next","_nextObjectPromise","set","_nextObjectPromiseWithTimeout","timeoutMS","nextObjectPromise","timeoutErr","timeoutPromise","timer","setTimeout","race","_nextObject","thisArg","_rewind","call","res","push","rewind","identity","getRawObjects","results","done","tail","docCallback","cursor","stopped","lastTS","loop","newSelector","$gt","defer","_observeChangesTailable","fieldsOptions","observeKey","stringify","multiplexer","observeDriver","firstHandle","_noYieldsAllowed","ObserveMultiplexer","onStop","observeHandle","ObserveHandle","matcher","sorter","canUseOplog","all","_testOnlyPollCallback","Minimongo","Matcher","OplogObserveDriver","cursorSupported","Sorter","f","driverClass","PollingObserveDriver","mongoHandle","_observeDriver","addHandleAndSendInitialAdds","listenAll","listenCallback","listeners","forEachTrigger","trigger","_InvalidationCrossbar","listen","listener","triggerCallback","addedBefore","added","MongoTimestamp","Connection"],"mappings":";AAAA,MAAIA,aAAJ;;AAAkBC,EAAAA,OAAO,CAACC,IAAR,CAAa,sCAAb,EAAoD;AAACC,IAAAA,OAAO,CAACC,CAAD,EAAG;AAACJ,MAAAA,aAAa,GAACI,CAAd;AAAgB;;AAA5B,GAApD,EAAkF,CAAlF;AAAlB,MAAIC,mBAAJ;AAAwBJ,EAAAA,OAAO,CAACC,IAAR,CAAa,eAAb,EAA6B;AAACG,IAAAA,mBAAmB,CAACD,CAAD,EAAG;AAACC,MAAAA,mBAAmB,GAACD,CAApB;AAAsB;;AAA9C,GAA7B,EAA6E,CAA7E;AAAgF,MAAIE,UAAJ;AAAeL,EAAAA,OAAO,CAACC,IAAR,CAAa,kBAAb,EAAgC;AAACI,IAAAA,UAAU,CAACF,CAAD,EAAG;AAACE,MAAAA,UAAU,GAACF,CAAX;AAAa;;AAA5B,GAAhC,EAA8D,CAA9D;;AAEvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,QAAMG,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AAEA,MAAIC,OAAO,GAAGC,gBAAd;;AACA,MAAIC,MAAM,GAAGC,GAAG,CAACJ,OAAJ,CAAY,eAAZ,CAAb;;AAGAK,EAAAA,cAAc,GAAG,EAAjB;AAEAA,EAAAA,cAAc,CAACC,UAAf,GAA4B;AAC1BC,IAAAA,OAAO,EAAE;AACPC,MAAAA,OAAO,EAAEC,uBADF;AAEPC,MAAAA,MAAM,EAAET;AAFD;AADiB,GAA5B,C,CAOA;AACA;AACA;AACA;;AACAI,EAAAA,cAAc,CAACM,SAAf,GAA2BV,OAA3B;AAEA,QAAMW,iBAAiB,GAAG,OAA1B;AACA,QAAMC,aAAa,GAAG,QAAtB;AACA,QAAMC,UAAU,GAAG,KAAnB,C,CAEA;AACA;;AACA,MAAIC,YAAY,GAAG,UAAUC,MAAV,EAAkBC,KAAlB,EAAyB;AAC1C,QAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;AAC/C,UAAIC,CAAC,CAACC,OAAF,CAAUF,KAAV,CAAJ,EAAsB;AACpB,eAAOC,CAAC,CAACE,GAAF,CAAMH,KAAN,EAAaC,CAAC,CAACG,IAAF,CAAON,YAAP,EAAqB,IAArB,EAA2BC,MAA3B,CAAb,CAAP;AACD;;AACD,UAAIM,GAAG,GAAG,EAAV;;AACAJ,MAAAA,CAAC,CAACK,IAAF,CAAON,KAAP,EAAc,UAAUO,KAAV,EAAiBC,GAAjB,EAAsB;AAClCH,QAAAA,GAAG,CAACN,MAAM,CAACS,GAAD,CAAP,CAAH,GAAmBV,YAAY,CAACC,MAAD,EAASQ,KAAT,CAA/B;AACD,OAFD;;AAGA,aAAOF,GAAP;AACD;;AACD,WAAOL,KAAP;AACD,GAZD,C,CAcA;AACA;AACA;;;AACAhB,EAAAA,OAAO,CAACyB,SAAR,CAAkBC,SAAlB,CAA4BC,KAA5B,GAAoC,YAAY;AAC9C;AACA,WAAO,IAAP;AACD,GAHD;;AAKA,MAAIC,cAAc,GAAG,UAAUC,IAAV,EAAgB;AAAE,WAAO,UAAUA,IAAjB;AAAwB,GAA/D;;AACA,MAAIC,gBAAgB,GAAG,UAAUD,IAAV,EAAgB;AAAE,WAAOA,IAAI,CAACE,MAAL,CAAY,CAAZ,CAAP;AAAwB,GAAjE;;AAEA,MAAIC,0BAA0B,GAAG,UAAUC,QAAV,EAAoB;AACnD,QAAIA,QAAQ,YAAYjC,OAAO,CAACkC,MAAhC,EAAwC;AACtC,UAAIC,MAAM,GAAGF,QAAQ,CAACV,KAAT,CAAe,IAAf,CAAb;AACA,aAAO,IAAIa,UAAJ,CAAeD,MAAf,CAAP;AACD;;AACD,QAAIF,QAAQ,YAAYjC,OAAO,CAACqC,QAAhC,EAA0C;AACxC,aAAO,IAAIC,KAAK,CAACD,QAAV,CAAmBJ,QAAQ,CAACM,WAAT,EAAnB,CAAP;AACD;;AACD,QAAIN,QAAQ,YAAYjC,OAAO,CAACwC,UAAhC,EAA4C;AAC1C,aAAOC,OAAO,CAACR,QAAQ,CAACS,QAAT,EAAD,CAAd;AACD;;AACD,QAAIT,QAAQ,CAAC,YAAD,CAAR,IAA0BA,QAAQ,CAAC,aAAD,CAAlC,IAAqDhB,CAAC,CAAC0B,IAAF,CAAOV,QAAP,MAAqB,CAA9E,EAAiF;AAC/E,aAAOW,KAAK,CAACC,aAAN,CAAoB/B,YAAY,CAACgB,gBAAD,EAAmBG,QAAnB,CAAhC,CAAP;AACD;;AACD,QAAIA,QAAQ,YAAYjC,OAAO,CAACyB,SAAhC,EAA2C;AACzC;AACA;AACA;AACA;AACA,aAAOQ,QAAP;AACD;;AACD,WAAOa,SAAP;AACD,GAtBD;;AAwBA,MAAIC,0BAA0B,GAAG,UAAUd,QAAV,EAAoB;AACnD,QAAIW,KAAK,CAACI,QAAN,CAAef,QAAf,CAAJ,EAA8B;AAC5B;AACA;AACA;AACA,aAAO,IAAIjC,OAAO,CAACkC,MAAZ,CAAmBe,MAAM,CAACC,IAAP,CAAYjB,QAAZ,CAAnB,CAAP;AACD;;AACD,QAAIA,QAAQ,YAAYK,KAAK,CAACD,QAA9B,EAAwC;AACtC,aAAO,IAAIrC,OAAO,CAACqC,QAAZ,CAAqBJ,QAAQ,CAACM,WAAT,EAArB,CAAP;AACD;;AACD,QAAIN,QAAQ,YAAYjC,OAAO,CAACyB,SAAhC,EAA2C;AACzC;AACA;AACA;AACA;AACA,aAAOQ,QAAP;AACD;;AACD,QAAIA,QAAQ,YAAYQ,OAAxB,EAAiC;AAC/B,aAAOzC,OAAO,CAACwC,UAAR,CAAmBW,UAAnB,CAA8BlB,QAAQ,CAACS,QAAT,EAA9B,CAAP;AACD;;AACD,QAAIE,KAAK,CAACQ,aAAN,CAAoBnB,QAApB,CAAJ,EAAmC;AACjC,aAAOnB,YAAY,CAACc,cAAD,EAAiBgB,KAAK,CAACS,WAAN,CAAkBpB,QAAlB,CAAjB,CAAnB;AACD,KAtBkD,CAuBnD;AACA;;;AACA,WAAOa,SAAP;AACD,GA1BD;;AA4BA,MAAIQ,YAAY,GAAG,UAAUrB,QAAV,EAAoBsB,eAApB,EAAqC;AACtD,QAAI,OAAOtB,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,IAAjD,EACE,OAAOA,QAAP;AAEF,QAAIuB,oBAAoB,GAAGD,eAAe,CAACtB,QAAD,CAA1C;AACA,QAAIuB,oBAAoB,KAAKV,SAA7B,EACE,OAAOU,oBAAP;AAEF,QAAInC,GAAG,GAAGY,QAAV;;AACAhB,IAAAA,CAAC,CAACK,IAAF,CAAOW,QAAP,EAAiB,UAAUwB,GAAV,EAAejC,GAAf,EAAoB;AACnC,UAAIkC,WAAW,GAAGJ,YAAY,CAACG,GAAD,EAAMF,eAAN,CAA9B;;AACA,UAAIE,GAAG,KAAKC,WAAZ,EAAyB;AACvB;AACA,YAAIrC,GAAG,KAAKY,QAAZ,EACEZ,GAAG,GAAGJ,CAAC,CAACU,KAAF,CAAQM,QAAR,CAAN;AACFZ,QAAAA,GAAG,CAACG,GAAD,CAAH,GAAWkC,WAAX;AACD;AACF,KARD;;AASA,WAAOrC,GAAP;AACD,GAnBD;;AAsBAsC,EAAAA,eAAe,GAAG,UAAUC,GAAV,EAAeC,OAAf,EAAwB;AAAA;;AACxC,QAAIC,IAAI,GAAG,IAAX;AACAD,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACAC,IAAAA,IAAI,CAACC,oBAAL,GAA4B,EAA5B;AACAD,IAAAA,IAAI,CAACE,eAAL,GAAuB,IAAIC,IAAJ,EAAvB;;AAEA,UAAMC,WAAW,mCACX5B,KAAK,CAAC6B,kBAAN,IAA4B,EADjB,GAEX,qBAAAC,MAAM,CAACC,QAAP,+FAAiBC,QAAjB,0GAA2BC,KAA3B,kFAAkCV,OAAlC,KAA6C,EAFlC,CAAjB;;AAKA,QAAIW,YAAY,GAAGC,MAAM,CAACC,MAAP,CAAc;AAC/BC,MAAAA,eAAe,EAAE;AADc,KAAd,EAEhBT,WAFgB,CAAnB,CAXwC,CAiBxC;AACA;;AACA,QAAIjD,CAAC,CAAC2D,GAAF,CAAMf,OAAN,EAAe,aAAf,CAAJ,EAAmC;AACjC;AACA;AACAW,MAAAA,YAAY,CAACK,WAAb,GAA2BhB,OAAO,CAACgB,WAAnC;AACD,KAvBuC,CAyBxC;AACA;;;AACAJ,IAAAA,MAAM,CAACK,OAAP,CAAeN,YAAY,IAAI,EAA/B,EACGzD,MADH,CACU;AAAA,UAAC,CAACS,GAAD,CAAD;AAAA,aAAWA,GAAG,IAAIA,GAAG,CAACuD,QAAJ,CAAapE,iBAAb,CAAlB;AAAA,KADV,EAEGqE,OAFH,CAEW,SAAkB;AAAA,UAAjB,CAACxD,GAAD,EAAMD,KAAN,CAAiB;AACzB,YAAM0D,UAAU,GAAGzD,GAAG,CAAC0D,OAAJ,CAAYvE,iBAAZ,EAA+B,EAA/B,CAAnB;AACA6D,MAAAA,YAAY,CAACS,UAAD,CAAZ,GAA2BnF,IAAI,CAACqF,IAAL,CAAUC,MAAM,CAACC,YAAP,EAAV,EACzBzE,aADyB,EACVC,UADU,EACEU,KADF,CAA3B;AAEA,aAAOiD,YAAY,CAAChD,GAAD,CAAnB;AACD,KAPH;AASAsC,IAAAA,IAAI,CAACwB,EAAL,GAAU,IAAV,CApCwC,CAqCxC;AACA;AACA;;AACAxB,IAAAA,IAAI,CAACyB,QAAL,GAAgB,IAAhB;AACAzB,IAAAA,IAAI,CAAC0B,YAAL,GAAoB,IAApB;AACA1B,IAAAA,IAAI,CAAC2B,WAAL,GAAmB,IAAnB;AAGA,QAAIC,aAAa,GAAG,IAAIxF,MAAJ,EAApB;AACA,QAAIF,OAAO,CAAC2F,WAAZ,CACE/B,GADF,EAEEY,YAFF,EAGEoB,OAHF,CAIExB,MAAM,CAACyB,eAAP,CACE,UAAUC,GAAV,EAAeC,MAAf,EAAuB;AACrB,UAAID,GAAJ,EAAS;AACP,cAAMA,GAAN;AACD;;AAED,UAAIR,EAAE,GAAGS,MAAM,CAACT,EAAP,EAAT;;AACA,UAAI;AACF,cAAMU,aAAa,GAAGV,EAAE,CAACW,KAAH,GAAWC,OAAX,CAAmB;AAACC,UAAAA,KAAK,EAAE;AAAR,SAAnB,EAA+BC,KAA/B,EAAtB,CADE,CAEF;;AACA,YAAIJ,aAAa,CAACK,OAAlB,EAA2B;AACzBvC,UAAAA,IAAI,CAACyB,QAAL,GAAgBS,aAAa,CAACK,OAA9B;AACD;AACF,OAND,CAMC,OAAMpF,CAAN,EAAQ;AACP;AACA,cAAMqF,gBAAgB,GAAGhB,EAAE,CAACW,KAAH,GAAWC,OAAX,CAAmB;AAACK,UAAAA,QAAQ,EAAC;AAAV,SAAnB,EAAiCH,KAAjC,EAAzB,CAFO,CAGP;;AACA,YAAIE,gBAAgB,CAACD,OAArB,EAA8B;AAC5BvC,UAAAA,IAAI,CAACyB,QAAL,GAAgBe,gBAAgB,CAACD,OAAjC;AACD;AACF;;AAEDN,MAAAA,MAAM,CAACS,QAAP,CAAgBC,EAAhB,CACE,QADF,EACYrC,MAAM,CAACyB,eAAP,CAAuB,UAAUa,IAAV,EAAgBC,GAAhB,EAAqB;AACpD,YAAID,IAAI,KAAK,SAAb,EAAwB;AACtB,cAAIC,GAAG,CAACN,OAAJ,KAAgBvC,IAAI,CAACyB,QAAzB,EAAmC;AACjCzB,YAAAA,IAAI,CAACyB,QAAL,GAAgBoB,GAAG,CAACN,OAApB;;AACAvC,YAAAA,IAAI,CAACE,eAAL,CAAqB1C,IAArB,CAA0B,UAAUsF,QAAV,EAAoB;AAC5CA,cAAAA,QAAQ;AACR,qBAAO,IAAP;AACD,aAHD;AAID;AACF,SARD,MAQO,IAAID,GAAG,CAACE,EAAJ,KAAW/C,IAAI,CAACyB,QAApB,EAA8B;AACnC;AACA;AACA;AACA;AACA;AACAzB,UAAAA,IAAI,CAACyB,QAAL,GAAgB,IAAhB;AACD;AACF,OAjBS,CADZ,EArBqB,CAyCrB;;AACAG,MAAAA,aAAa,CAAC,QAAD,CAAb,CAAwB;AAAEK,QAAAA,MAAF;AAAUT,QAAAA;AAAV,OAAxB;AACD,KA5CH,EA6CEI,aAAa,CAACoB,QAAd,EA7CF,CA6C4B;AA7C5B,KAJF,EA9CwC,CAmGxC;AACA;;AACArC,IAAAA,MAAM,CAACC,MAAP,CAAcZ,IAAd,EAAoB4B,aAAa,CAACqB,IAAd,EAApB;;AAEA,QAAIlD,OAAO,CAACmD,QAAR,IAAoB,CAAEC,OAAO,CAAC,eAAD,CAAjC,EAAoD;AAClDnD,MAAAA,IAAI,CAAC0B,YAAL,GAAoB,IAAI0B,WAAJ,CAAgBrD,OAAO,CAACmD,QAAxB,EAAkClD,IAAI,CAACwB,EAAL,CAAQ6B,YAA1C,CAApB;AACArD,MAAAA,IAAI,CAAC2B,WAAL,GAAmB,IAAI5F,UAAJ,CAAeiE,IAAf,CAAnB;AACD;AACF,GA3GD;;AA6GAH,EAAAA,eAAe,CAACjC,SAAhB,CAA0B0F,KAA1B,GAAkC,YAAW;AAC3C,QAAItD,IAAI,GAAG,IAAX;AAEA,QAAI,CAAEA,IAAI,CAACwB,EAAX,EACE,MAAM+B,KAAK,CAAC,yCAAD,CAAX,CAJyC,CAM3C;;AACA,QAAIC,WAAW,GAAGxD,IAAI,CAAC0B,YAAvB;AACA1B,IAAAA,IAAI,CAAC0B,YAAL,GAAoB,IAApB;AACA,QAAI8B,WAAJ,EACEA,WAAW,CAACC,IAAZ,GAVyC,CAY3C;AACA;AACA;;AACArH,IAAAA,MAAM,CAACsH,IAAP,CAAYvG,CAAC,CAACG,IAAF,CAAO0C,IAAI,CAACiC,MAAL,CAAYqB,KAAnB,EAA0BtD,IAAI,CAACiC,MAA/B,CAAZ,EAAoD,IAApD,EAA0DgB,IAA1D;AACD,GAhBD,C,CAkBA;;;AACApD,EAAAA,eAAe,CAACjC,SAAhB,CAA0B+F,aAA1B,GAA0C,UAAUC,cAAV,EAA0B;AAClE,QAAI5D,IAAI,GAAG,IAAX;AAEA,QAAI,CAAEA,IAAI,CAACwB,EAAX,EACE,MAAM+B,KAAK,CAAC,iDAAD,CAAX;AAEF,WAAOvD,IAAI,CAACwB,EAAL,CAAQqC,UAAR,CAAmBD,cAAnB,CAAP;AACD,GAPD;;AASA/D,EAAAA,eAAe,CAACjC,SAAhB,CAA0BkG,uBAA1B,GAAoD,UAChDF,cADgD,EAChCG,QADgC,EACtBC,YADsB,EACR;AAC1C,QAAIhE,IAAI,GAAG,IAAX;AAEA,QAAI,CAAEA,IAAI,CAACwB,EAAX,EACE,MAAM+B,KAAK,CAAC,2DAAD,CAAX;AAEF,QAAIU,MAAM,GAAG,IAAI7H,MAAJ,EAAb;AACA4D,IAAAA,IAAI,CAACwB,EAAL,CAAQ0C,gBAAR,CACEN,cADF,EAEE;AAAEO,MAAAA,MAAM,EAAE,IAAV;AAAgBtF,MAAAA,IAAI,EAAEkF,QAAtB;AAAgCK,MAAAA,GAAG,EAAEJ;AAArC,KAFF,EAGEC,MAAM,CAACjB,QAAP,EAHF;AAIAiB,IAAAA,MAAM,CAAChB,IAAP;AACD,GAbD,C,CAeA;AACA;AACA;AACA;AACA;;;AACApD,EAAAA,eAAe,CAACjC,SAAhB,CAA0ByG,gBAA1B,GAA6C,YAAY;AACvD,QAAIC,KAAK,GAAGC,SAAS,CAACC,kBAAV,CAA6BC,GAA7B,EAAZ;;AACA,QAAIH,KAAJ,EAAW;AACT,aAAOA,KAAK,CAACI,UAAN,EAAP;AACD,KAFD,MAEO;AACL,aAAO;AAACC,QAAAA,SAAS,EAAE,YAAY,CAAE;AAA1B,OAAP;AACD;AACF,GAPD,C,CASA;AACA;;;AACA9E,EAAAA,eAAe,CAACjC,SAAhB,CAA0BgH,WAA1B,GAAwC,UAAU9B,QAAV,EAAoB;AAC1D,WAAO,KAAK5C,eAAL,CAAqB2E,QAArB,CAA8B/B,QAA9B,CAAP;AACD,GAFD,C,CAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAIgC,aAAa,GAAG,UAAUC,KAAV,EAAiBC,OAAjB,EAA0BlC,QAA1B,EAAoC;AACtD,WAAO,UAAUd,GAAV,EAAeiD,MAAf,EAAuB;AAC5B,UAAI,CAAEjD,GAAN,EAAW;AACT;AACA,YAAI;AACFgD,UAAAA,OAAO;AACR,SAFD,CAEE,OAAOE,UAAP,EAAmB;AACnB,cAAIpC,QAAJ,EAAc;AACZA,YAAAA,QAAQ,CAACoC,UAAD,CAAR;AACA;AACD,WAHD,MAGO;AACL,kBAAMA,UAAN;AACD;AACF;AACF;;AACDH,MAAAA,KAAK,CAACJ,SAAN;;AACA,UAAI7B,QAAJ,EAAc;AACZA,QAAAA,QAAQ,CAACd,GAAD,EAAMiD,MAAN,CAAR;AACD,OAFD,MAEO,IAAIjD,GAAJ,EAAS;AACd,cAAMA,GAAN;AACD;AACF,KApBD;AAqBD,GAtBD;;AAwBA,MAAImD,uBAAuB,GAAG,UAAUrC,QAAV,EAAoB;AAChD,WAAOxC,MAAM,CAACyB,eAAP,CAAuBe,QAAvB,EAAiC,aAAjC,CAAP;AACD,GAFD;;AAIAjD,EAAAA,eAAe,CAACjC,SAAhB,CAA0BwH,OAA1B,GAAoC,UAAUC,eAAV,EAA2BlH,QAA3B,EACU2E,QADV,EACoB;AACtD,QAAI9C,IAAI,GAAG,IAAX;;AAEA,QAAIsF,SAAS,GAAG,UAAUC,CAAV,EAAa;AAC3B,UAAIzC,QAAJ,EACE,OAAOA,QAAQ,CAACyC,CAAD,CAAf;AACF,YAAMA,CAAN;AACD,KAJD;;AAMA,QAAIF,eAAe,KAAK,mCAAxB,EAA6D;AAC3D,UAAIE,CAAC,GAAG,IAAIhC,KAAJ,CAAU,cAAV,CAAR;AACAgC,MAAAA,CAAC,CAACC,eAAF,GAAoB,IAApB;AACAF,MAAAA,SAAS,CAACC,CAAD,CAAT;AACA;AACD;;AAED,QAAI,EAAEE,eAAe,CAACC,cAAhB,CAA+BvH,QAA/B,KACA,CAACW,KAAK,CAACQ,aAAN,CAAoBnB,QAApB,CADH,CAAJ,EACuC;AACrCmH,MAAAA,SAAS,CAAC,IAAI/B,KAAJ,CACR,iDADQ,CAAD,CAAT;AAEA;AACD;;AAED,QAAIwB,KAAK,GAAG/E,IAAI,CAACqE,gBAAL,EAAZ;;AACA,QAAIW,OAAO,GAAG,YAAY;AACxB1E,MAAAA,MAAM,CAAC0E,OAAP,CAAe;AAACnB,QAAAA,UAAU,EAAEwB,eAAb;AAA8BM,QAAAA,EAAE,EAAExH,QAAQ,CAACyH;AAA3C,OAAf;AACD,KAFD;;AAGA9C,IAAAA,QAAQ,GAAGqC,uBAAuB,CAACL,aAAa,CAACC,KAAD,EAAQC,OAAR,EAAiBlC,QAAjB,CAAd,CAAlC;;AACA,QAAI;AACF,UAAIe,UAAU,GAAG7D,IAAI,CAAC2D,aAAL,CAAmB0B,eAAnB,CAAjB;AACAxB,MAAAA,UAAU,CAACgC,SAAX,CACErG,YAAY,CAACrB,QAAD,EAAWc,0BAAX,CADd,EAEE;AACE6G,QAAAA,IAAI,EAAE;AADR,OAFF,EAKEC,IALF,CAKO,SAAkB;AAAA,YAAjB;AAACC,UAAAA;AAAD,SAAiB;AACvBlD,QAAAA,QAAQ,CAAC,IAAD,EAAOkD,UAAP,CAAR;AACD,OAPD,EAOGC,KAPH,CAOUV,CAAD,IAAO;AACdzC,QAAAA,QAAQ,CAACyC,CAAD,EAAI,IAAJ,CAAR;AACD,OATD;AAUD,KAZD,CAYE,OAAOvD,GAAP,EAAY;AACZ+C,MAAAA,KAAK,CAACJ,SAAN;AACA,YAAM3C,GAAN;AACD;AACF,GA7CD,C,CA+CA;AACA;;;AACAnC,EAAAA,eAAe,CAACjC,SAAhB,CAA0BsI,QAA1B,GAAqC,UAAUtC,cAAV,EAA0BuC,QAA1B,EAAoC;AACvE,QAAIC,UAAU,GAAG;AAACvC,MAAAA,UAAU,EAAED;AAAb,KAAjB,CADuE,CAEvE;AACA;AACA;AACA;;AACA,QAAIyC,WAAW,GAAGZ,eAAe,CAACa,qBAAhB,CAAsCH,QAAtC,CAAlB;;AACA,QAAIE,WAAJ,EAAiB;AACflJ,MAAAA,CAAC,CAACK,IAAF,CAAO6I,WAAP,EAAoB,UAAUV,EAAV,EAAc;AAChCrF,QAAAA,MAAM,CAAC0E,OAAP,CAAe7H,CAAC,CAACoJ,MAAF,CAAS;AAACZ,UAAAA,EAAE,EAAEA;AAAL,SAAT,EAAmBS,UAAnB,CAAf;AACD,OAFD;AAGD,KAJD,MAIO;AACL9F,MAAAA,MAAM,CAAC0E,OAAP,CAAeoB,UAAf;AACD;AACF,GAdD;;AAgBAvG,EAAAA,eAAe,CAACjC,SAAhB,CAA0B4I,OAA1B,GAAoC,UAAUnB,eAAV,EAA2Bc,QAA3B,EACUrD,QADV,EACoB;AACtD,QAAI9C,IAAI,GAAG,IAAX;;AAEA,QAAIqF,eAAe,KAAK,mCAAxB,EAA6D;AAC3D,UAAIE,CAAC,GAAG,IAAIhC,KAAJ,CAAU,cAAV,CAAR;AACAgC,MAAAA,CAAC,CAACC,eAAF,GAAoB,IAApB;;AACA,UAAI1C,QAAJ,EAAc;AACZ,eAAOA,QAAQ,CAACyC,CAAD,CAAf;AACD,OAFD,MAEO;AACL,cAAMA,CAAN;AACD;AACF;;AAED,QAAIR,KAAK,GAAG/E,IAAI,CAACqE,gBAAL,EAAZ;;AACA,QAAIW,OAAO,GAAG,YAAY;AACxBhF,MAAAA,IAAI,CAACkG,QAAL,CAAcb,eAAd,EAA+Bc,QAA/B;AACD,KAFD;;AAGArD,IAAAA,QAAQ,GAAGqC,uBAAuB,CAACL,aAAa,CAACC,KAAD,EAAQC,OAAR,EAAiBlC,QAAjB,CAAd,CAAlC;;AAEA,QAAI;AACF,UAAIe,UAAU,GAAG7D,IAAI,CAAC2D,aAAL,CAAmB0B,eAAnB,CAAjB;AACAxB,MAAAA,UAAU,CACP4C,UADH,CACcjH,YAAY,CAAC2G,QAAD,EAAWlH,0BAAX,CAD1B,EACkE;AAC9D6G,QAAAA,IAAI,EAAE;AADwD,OADlE,EAIGC,IAJH,CAIQ,SAAsB;AAAA,YAArB;AAAEW,UAAAA;AAAF,SAAqB;AAC1B5D,QAAAA,QAAQ,CAAC,IAAD,EAAO6D,eAAe,CAAC;AAAE1B,UAAAA,MAAM,EAAG;AAAC2B,YAAAA,aAAa,EAAGF;AAAjB;AAAX,SAAD,CAAf,CAA6DG,cAApE,CAAR;AACD,OANH,EAMKZ,KANL,CAMYjE,GAAD,IAAS;AAClBc,QAAAA,QAAQ,CAACd,GAAD,CAAR;AACD,OARD;AASD,KAXD,CAWE,OAAOA,GAAP,EAAY;AACZ+C,MAAAA,KAAK,CAACJ,SAAN;AACA,YAAM3C,GAAN;AACD;AACF,GAnCD;;AAqCAnC,EAAAA,eAAe,CAACjC,SAAhB,CAA0BkJ,eAA1B,GAA4C,UAAUlD,cAAV,EAA0BmD,EAA1B,EAA8B;AACxE,QAAI/G,IAAI,GAAG,IAAX;;AAEA,QAAI+E,KAAK,GAAG/E,IAAI,CAACqE,gBAAL,EAAZ;;AACA,QAAIW,OAAO,GAAG,YAAY;AACxB1E,MAAAA,MAAM,CAAC0E,OAAP,CAAe;AAACnB,QAAAA,UAAU,EAAED,cAAb;AAA6B+B,QAAAA,EAAE,EAAE,IAAjC;AACCqB,QAAAA,cAAc,EAAE;AADjB,OAAf;AAED,KAHD;;AAIAD,IAAAA,EAAE,GAAG5B,uBAAuB,CAACL,aAAa,CAACC,KAAD,EAAQC,OAAR,EAAiB+B,EAAjB,CAAd,CAA5B;;AAEA,QAAI;AACF,UAAIlD,UAAU,GAAG7D,IAAI,CAAC2D,aAAL,CAAmBC,cAAnB,CAAjB;AACAC,MAAAA,UAAU,CAACoD,IAAX,CAAgBF,EAAhB;AACD,KAHD,CAGE,OAAOxB,CAAP,EAAU;AACVR,MAAAA,KAAK,CAACJ,SAAN;AACA,YAAMY,CAAN;AACD;AACF,GAjBD,C,CAmBA;AACA;;;AACA1F,EAAAA,eAAe,CAACjC,SAAhB,CAA0BsJ,aAA1B,GAA0C,UAAUH,EAAV,EAAc;AACtD,QAAI/G,IAAI,GAAG,IAAX;;AAEA,QAAI+E,KAAK,GAAG/E,IAAI,CAACqE,gBAAL,EAAZ;;AACA,QAAIW,OAAO,GAAG,YAAY;AACxB1E,MAAAA,MAAM,CAAC0E,OAAP,CAAe;AAAEmC,QAAAA,YAAY,EAAE;AAAhB,OAAf;AACD,KAFD;;AAGAJ,IAAAA,EAAE,GAAG5B,uBAAuB,CAACL,aAAa,CAACC,KAAD,EAAQC,OAAR,EAAiB+B,EAAjB,CAAd,CAA5B;;AAEA,QAAI;AACF/G,MAAAA,IAAI,CAACwB,EAAL,CAAQ2F,YAAR,CAAqBJ,EAArB;AACD,KAFD,CAEE,OAAOxB,CAAP,EAAU;AACVR,MAAAA,KAAK,CAACJ,SAAN;AACA,YAAMY,CAAN;AACD;AACF,GAfD;;AAiBA1F,EAAAA,eAAe,CAACjC,SAAhB,CAA0BwJ,OAA1B,GAAoC,UAAU/B,eAAV,EAA2Bc,QAA3B,EAAqCkB,GAArC,EACUtH,OADV,EACmB+C,QADnB,EAC6B;AAC/D,QAAI9C,IAAI,GAAG,IAAX;;AAEA,QAAI,CAAE8C,QAAF,IAAc/C,OAAO,YAAYuH,QAArC,EAA+C;AAC7CxE,MAAAA,QAAQ,GAAG/C,OAAX;AACAA,MAAAA,OAAO,GAAG,IAAV;AACD;;AAED,QAAIsF,eAAe,KAAK,mCAAxB,EAA6D;AAC3D,UAAIE,CAAC,GAAG,IAAIhC,KAAJ,CAAU,cAAV,CAAR;AACAgC,MAAAA,CAAC,CAACC,eAAF,GAAoB,IAApB;;AACA,UAAI1C,QAAJ,EAAc;AACZ,eAAOA,QAAQ,CAACyC,CAAD,CAAf;AACD,OAFD,MAEO;AACL,cAAMA,CAAN;AACD;AACF,KAhB8D,CAkB/D;AACA;AACA;AACA;AACA;;;AACA,QAAI,CAAC8B,GAAD,IAAQ,OAAOA,GAAP,KAAe,QAA3B,EACE,MAAM,IAAI9D,KAAJ,CAAU,+CAAV,CAAN;;AAEF,QAAI,EAAEkC,eAAe,CAACC,cAAhB,CAA+B2B,GAA/B,KACA,CAACvI,KAAK,CAACQ,aAAN,CAAoB+H,GAApB,CADH,CAAJ,EACkC;AAChC,YAAM,IAAI9D,KAAJ,CACJ,kDACE,uBAFE,CAAN;AAGD;;AAED,QAAI,CAACxD,OAAL,EAAcA,OAAO,GAAG,EAAV;;AAEd,QAAIgF,KAAK,GAAG/E,IAAI,CAACqE,gBAAL,EAAZ;;AACA,QAAIW,OAAO,GAAG,YAAY;AACxBhF,MAAAA,IAAI,CAACkG,QAAL,CAAcb,eAAd,EAA+Bc,QAA/B;AACD,KAFD;;AAGArD,IAAAA,QAAQ,GAAGgC,aAAa,CAACC,KAAD,EAAQC,OAAR,EAAiBlC,QAAjB,CAAxB;;AACA,QAAI;AACF,UAAIe,UAAU,GAAG7D,IAAI,CAAC2D,aAAL,CAAmB0B,eAAnB,CAAjB;AACA,UAAIkC,SAAS,GAAG;AAACzB,QAAAA,IAAI,EAAE;AAAP,OAAhB,CAFE,CAGF;;AACA,UAAI/F,OAAO,CAACyH,YAAR,KAAyBxI,SAA7B,EAAwCuI,SAAS,CAACC,YAAV,GAAyBzH,OAAO,CAACyH,YAAjC,CAJtC,CAKF;;AACA,UAAIzH,OAAO,CAAC0H,MAAZ,EAAoBF,SAAS,CAACE,MAAV,GAAmB,IAAnB;AACpB,UAAI1H,OAAO,CAAC2H,KAAZ,EAAmBH,SAAS,CAACG,KAAV,GAAkB,IAAlB,CAPjB,CAQF;AACA;AACA;;AACA,UAAI3H,OAAO,CAAC4H,UAAZ,EAAwBJ,SAAS,CAACI,UAAV,GAAuB,IAAvB;AAExB,UAAIC,aAAa,GAAGpI,YAAY,CAAC2G,QAAD,EAAWlH,0BAAX,CAAhC;AACA,UAAI4I,QAAQ,GAAGrI,YAAY,CAAC6H,GAAD,EAAMpI,0BAAN,CAA3B;;AAEA,UAAI6I,QAAQ,GAAGrC,eAAe,CAACsC,kBAAhB,CAAmCF,QAAnC,CAAf;;AAEA,UAAI9H,OAAO,CAACiI,cAAR,IAA0B,CAACF,QAA/B,EAAyC;AACvC,YAAI9F,GAAG,GAAG,IAAIuB,KAAJ,CAAU,+CAAV,CAAV;;AACA,YAAIT,QAAJ,EAAc;AACZ,iBAAOA,QAAQ,CAACd,GAAD,CAAf;AACD,SAFD,MAEO;AACL,gBAAMA,GAAN;AACD;AACF,OAzBC,CA2BF;AACA;AACA;AACA;AAEA;AACA;;;AACA,UAAIiG,OAAJ;;AACA,UAAIlI,OAAO,CAAC0H,MAAZ,EAAoB;AAClB,YAAI;AACF,cAAIS,MAAM,GAAGzC,eAAe,CAAC0C,qBAAhB,CAAsChC,QAAtC,EAAgDkB,GAAhD,CAAb;;AACAY,UAAAA,OAAO,GAAGC,MAAM,CAACtC,GAAjB;AACD,SAHD,CAGE,OAAO5D,GAAP,EAAY;AACZ,cAAIc,QAAJ,EAAc;AACZ,mBAAOA,QAAQ,CAACd,GAAD,CAAf;AACD,WAFD,MAEO;AACL,kBAAMA,GAAN;AACD;AACF;AACF;;AAED,UAAIjC,OAAO,CAAC0H,MAAR,IACA,CAAEK,QADF,IAEA,CAAEG,OAFF,IAGAlI,OAAO,CAACiG,UAHR,IAIA,EAAGjG,OAAO,CAACiG,UAAR,YAA8BxH,KAAK,CAACD,QAApC,IACAwB,OAAO,CAACqI,WADX,CAJJ,EAK6B;AAC3B;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEAC,QAAAA,4BAA4B,CAC1BxE,UAD0B,EACd+D,aADc,EACCC,QADD,EACW9H,OADX,EAE1B;AACA;AACA;AACA,kBAAUuI,KAAV,EAAiBrD,MAAjB,EAAyB;AACvB;AACA;AACA;AACA,cAAIA,MAAM,IAAI,CAAElF,OAAO,CAACwI,aAAxB,EAAuC;AACrCzF,YAAAA,QAAQ,CAACwF,KAAD,EAAQrD,MAAM,CAAC4B,cAAf,CAAR;AACD,WAFD,MAEO;AACL/D,YAAAA,QAAQ,CAACwF,KAAD,EAAQrD,MAAR,CAAR;AACD;AACF,SAdyB,CAA5B;AAgBD,OAhCD,MAgCO;AAEL,YAAIlF,OAAO,CAAC0H,MAAR,IAAkB,CAACQ,OAAnB,IAA8BlI,OAAO,CAACiG,UAAtC,IAAoD8B,QAAxD,EAAkE;AAChE,cAAI,CAACD,QAAQ,CAACW,cAAT,CAAwB,cAAxB,CAAL,EAA8C;AAC5CX,YAAAA,QAAQ,CAACY,YAAT,GAAwB,EAAxB;AACD;;AACDR,UAAAA,OAAO,GAAGlI,OAAO,CAACiG,UAAlB;AACArF,UAAAA,MAAM,CAACC,MAAP,CAAciH,QAAQ,CAACY,YAAvB,EAAqCjJ,YAAY,CAAC;AAACoG,YAAAA,GAAG,EAAE7F,OAAO,CAACiG;AAAd,WAAD,EAA4B/G,0BAA5B,CAAjD;AACD;;AAED,cAAMyJ,OAAO,GAAG/H,MAAM,CAACgI,IAAP,CAAYd,QAAZ,EAAsB5K,MAAtB,CAA8BS,GAAD,IAAS,CAACA,GAAG,CAACkL,UAAJ,CAAe,GAAf,CAAvC,CAAhB;AACA,YAAIC,YAAY,GAAGH,OAAO,CAACI,MAAR,GAAiB,CAAjB,GAAqB,YAArB,GAAoC,YAAvD;AACAD,QAAAA,YAAY,GACVA,YAAY,KAAK,YAAjB,IAAiC,CAACtB,SAAS,CAACG,KAA5C,GACI,WADJ,GAEImB,YAHN;AAIAhF,QAAAA,UAAU,CAACgF,YAAD,CAAV,CAAyBvL,IAAzB,CAA8BuG,UAA9B,EACE+D,aADF,EACiBC,QADjB,EAC2BN,SAD3B,EAEI;AACApC,QAAAA,uBAAuB,CAAC,YAA8B;AAAA,cAApBnD,GAAoB,uEAAd,IAAc;AAAA,cAARiD,MAAQ;;AACtD,cAAI,CAAEjD,GAAN,EAAW;AACT,gBAAI+G,YAAY,GAAGpC,eAAe,CAAC;AAAC1B,cAAAA;AAAD,aAAD,CAAlC;;AACA,gBAAI8D,YAAY,IAAIhJ,OAAO,CAACwI,aAA5B,EAA2C;AACzC;AACA;AACA;AACA,kBAAIxI,OAAO,CAAC0H,MAAR,IAAkBsB,YAAY,CAAC/C,UAAnC,EAA+C;AAC7C,oBAAIiC,OAAJ,EAAa;AACXc,kBAAAA,YAAY,CAAC/C,UAAb,GAA0BiC,OAA1B;AACD,iBAFD,MAEO,IAAIc,YAAY,CAAC/C,UAAb,YAAmC9J,OAAO,CAACqC,QAA/C,EAAyD;AAC9DwK,kBAAAA,YAAY,CAAC/C,UAAb,GAA0B,IAAIxH,KAAK,CAACD,QAAV,CAAmBwK,YAAY,CAAC/C,UAAb,CAAwBvH,WAAxB,EAAnB,CAA1B;AACD;AACF;;AAEDqE,cAAAA,QAAQ,CAACd,GAAD,EAAM+G,YAAN,CAAR;AACD,aAbD,MAaO;AACLjG,cAAAA,QAAQ,CAACd,GAAD,EAAM+G,YAAY,CAAClC,cAAnB,CAAR;AACD;AACF,WAlBD,MAkBO;AACL/D,YAAAA,QAAQ,CAACd,GAAD,CAAR;AACD;AACF,SAtBwB,CAH3B;AA0BD;AACF,KA3HD,CA2HE,OAAOuD,CAAP,EAAU;AACVR,MAAAA,KAAK,CAACJ,SAAN;AACA,YAAMY,CAAN;AACD;AACF,GAxKD;;AA0KA,MAAIoB,eAAe,GAAG,UAAUqC,YAAV,EAAwB;AAC5C,QAAID,YAAY,GAAG;AAAElC,MAAAA,cAAc,EAAE;AAAlB,KAAnB;;AACA,QAAImC,YAAJ,EAAkB;AAChB,UAAIC,WAAW,GAAGD,YAAY,CAAC/D,MAA/B,CADgB,CAEhB;AACA;AACA;;AACA,UAAIgE,WAAW,CAACC,aAAhB,EAA+B;AAC7BH,QAAAA,YAAY,CAAClC,cAAb,GAA8BoC,WAAW,CAACC,aAA1C;;AAEA,YAAID,WAAW,CAACE,UAAhB,EAA4B;AAC1BJ,UAAAA,YAAY,CAAC/C,UAAb,GAA0BiD,WAAW,CAACE,UAAtC;AACD;AACF,OAND,MAMO;AACL;AACA;AACAJ,QAAAA,YAAY,CAAClC,cAAb,GAA8BoC,WAAW,CAACG,CAAZ,IAAiBH,WAAW,CAACI,YAA7B,IAA6CJ,WAAW,CAACrC,aAAvF;AACD;AACF;;AAED,WAAOmC,YAAP;AACD,GArBD;;AAwBA,MAAIO,oBAAoB,GAAG,CAA3B,C,CAEA;;AACAzJ,EAAAA,eAAe,CAAC0J,sBAAhB,GAAyC,UAAUvH,GAAV,EAAe;AAEtD;AACA;AACA;AACA;AACA,QAAIsG,KAAK,GAAGtG,GAAG,CAACwH,MAAJ,IAAcxH,GAAG,CAACA,GAA9B,CANsD,CAQtD;AACA;AACA;;AACA,QAAIsG,KAAK,CAACmB,OAAN,CAAc,iCAAd,MAAqD,CAArD,IACCnB,KAAK,CAACmB,OAAN,CAAc,mEAAd,MAAuF,CAAC,CAD7F,EACgG;AAC9F,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD,GAjBD;;AAmBA,MAAIpB,4BAA4B,GAAG,UAAUxE,UAAV,EAAsBsC,QAAtB,EAAgCkB,GAAhC,EACUtH,OADV,EACmB+C,QADnB,EAC6B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,QAAIkD,UAAU,GAAGjG,OAAO,CAACiG,UAAzB,CAd8D,CAczB;;AACrC,QAAI0D,kBAAkB,GAAG;AACvB5D,MAAAA,IAAI,EAAE,IADiB;AAEvB4B,MAAAA,KAAK,EAAE3H,OAAO,CAAC2H;AAFQ,KAAzB;AAIA,QAAIiC,kBAAkB,GAAG;AACvB7D,MAAAA,IAAI,EAAE,IADiB;AAEvB2B,MAAAA,MAAM,EAAE;AAFe,KAAzB;AAKA,QAAImC,iBAAiB,GAAGjJ,MAAM,CAACC,MAAP,CACtBpB,YAAY,CAAC;AAACoG,MAAAA,GAAG,EAAEI;AAAN,KAAD,EAAoB/G,0BAApB,CADU,EAEtBoI,GAFsB,CAAxB;AAIA,QAAIwC,KAAK,GAAGP,oBAAZ;;AAEA,QAAIQ,QAAQ,GAAG,YAAY;AACzBD,MAAAA,KAAK;;AACL,UAAI,CAAEA,KAAN,EAAa;AACX/G,QAAAA,QAAQ,CAAC,IAAIS,KAAJ,CAAU,yBAAyB+F,oBAAzB,GAAgD,SAA1D,CAAD,CAAR;AACD,OAFD,MAEO;AACL,YAAIS,MAAM,GAAGlG,UAAU,CAACmG,UAAxB;;AACA,YAAG,CAACrJ,MAAM,CAACgI,IAAP,CAAYtB,GAAZ,EAAiB4C,IAAjB,CAAsBvM,GAAG,IAAIA,GAAG,CAACkL,UAAJ,CAAe,GAAf,CAA7B,CAAJ,EAAsD;AACpDmB,UAAAA,MAAM,GAAGlG,UAAU,CAACqG,UAAX,CAAsB5M,IAAtB,CAA2BuG,UAA3B,CAAT;AACD;;AACDkG,QAAAA,MAAM,CACJ5D,QADI,EAEJkB,GAFI,EAGJqC,kBAHI,EAIJvE,uBAAuB,CAAC,UAASnD,GAAT,EAAciD,MAAd,EAAsB;AAC5C,cAAIjD,GAAJ,EAAS;AACPc,YAAAA,QAAQ,CAACd,GAAD,CAAR;AACD,WAFD,MAEO,IAAIiD,MAAM,KAAKA,MAAM,CAAC2B,aAAP,IAAwB3B,MAAM,CAACiE,aAApC,CAAV,EAA8D;AACnEpG,YAAAA,QAAQ,CAAC,IAAD,EAAO;AACb+D,cAAAA,cAAc,EAAE5B,MAAM,CAAC2B,aAAP,IAAwB3B,MAAM,CAACiE,aADlC;AAEblD,cAAAA,UAAU,EAAEf,MAAM,CAACkE,UAAP,IAAqBnK;AAFpB,aAAP,CAAR;AAID,WALM,MAKA;AACLmL,YAAAA,mBAAmB;AACpB;AACF,SAXsB,CAJnB,CAAN;AAiBD;AACF,KA3BD;;AA6BA,QAAIA,mBAAmB,GAAG,YAAW;AACnCtG,MAAAA,UAAU,CAACqG,UAAX,CACE/D,QADF,EAEEyD,iBAFF,EAGED,kBAHF,EAIExE,uBAAuB,CAAC,UAASnD,GAAT,EAAciD,MAAd,EAAsB;AAC5C,YAAIjD,GAAJ,EAAS;AACP;AACA;AACA;AACA,cAAInC,eAAe,CAAC0J,sBAAhB,CAAuCvH,GAAvC,CAAJ,EAAiD;AAC/C8H,YAAAA,QAAQ;AACT,WAFD,MAEO;AACLhH,YAAAA,QAAQ,CAACd,GAAD,CAAR;AACD;AACF,SATD,MASO;AACLc,UAAAA,QAAQ,CAAC,IAAD,EAAO;AACb+D,YAAAA,cAAc,EAAE5B,MAAM,CAACiE,aADV;AAEblD,YAAAA,UAAU,EAAEf,MAAM,CAACkE;AAFN,WAAP,CAAR;AAID;AACF,OAhBsB,CAJzB;AAsBD,KAvBD;;AAyBAW,IAAAA,QAAQ;AACT,GAtFD;;AAwFA3M,EAAAA,CAAC,CAACK,IAAF,CAAO,CAAC,QAAD,EAAW,QAAX,EAAqB,QAArB,EAA+B,gBAA/B,EAAiD,cAAjD,CAAP,EAAyE,UAAUuM,MAAV,EAAkB;AACzFlK,IAAAA,eAAe,CAACjC,SAAhB,CAA0BmM,MAA1B,IAAoC;AAAU;AAAV,OAA2B;AAC7D,UAAI/J,IAAI,GAAG,IAAX;AACA,aAAOM,MAAM,CAAC8J,SAAP,CAAiBpK,IAAI,CAAC,MAAM+J,MAAP,CAArB,EAAqCM,KAArC,CAA2CrK,IAA3C,EAAiDsK,SAAjD,CAAP;AACD,KAHD;AAID,GALD,E,CAOA;AACA;AACA;;;AACAzK,EAAAA,eAAe,CAACjC,SAAhB,CAA0B6J,MAA1B,GAAmC,UAAU7D,cAAV,EAA0BuC,QAA1B,EAAoCkB,GAApC,EACUtH,OADV,EACmB+C,QADnB,EAC6B;AAC9D,QAAI9C,IAAI,GAAG,IAAX;;AACA,QAAI,OAAOD,OAAP,KAAmB,UAAnB,IAAiC,CAAE+C,QAAvC,EAAiD;AAC/CA,MAAAA,QAAQ,GAAG/C,OAAX;AACAA,MAAAA,OAAO,GAAG,EAAV;AACD;;AAED,WAAOC,IAAI,CAACuK,MAAL,CAAY3G,cAAZ,EAA4BuC,QAA5B,EAAsCkB,GAAtC,EACYlK,CAAC,CAACoJ,MAAF,CAAS,EAAT,EAAaxG,OAAb,EAAsB;AACpB0H,MAAAA,MAAM,EAAE,IADY;AAEpBc,MAAAA,aAAa,EAAE;AAFK,KAAtB,CADZ,EAIgBzF,QAJhB,CAAP;AAKD,GAbD;;AAeAjD,EAAAA,eAAe,CAACjC,SAAhB,CAA0B4M,IAA1B,GAAiC,UAAU5G,cAAV,EAA0BuC,QAA1B,EAAoCpG,OAApC,EAA6C;AAC5E,QAAIC,IAAI,GAAG,IAAX;AAEA,QAAIsK,SAAS,CAACxB,MAAV,KAAqB,CAAzB,EACE3C,QAAQ,GAAG,EAAX;AAEF,WAAO,IAAIsE,MAAJ,CACLzK,IADK,EACC,IAAI0K,iBAAJ,CAAsB9G,cAAtB,EAAsCuC,QAAtC,EAAgDpG,OAAhD,CADD,CAAP;AAED,GARD;;AAUAF,EAAAA,eAAe,CAACjC,SAAhB,CAA0B+M,OAA1B,GAAoC,UAAUtF,eAAV,EAA2Bc,QAA3B,EACUpG,OADV,EACmB;AACrD,QAAIC,IAAI,GAAG,IAAX;AACA,QAAIsK,SAAS,CAACxB,MAAV,KAAqB,CAAzB,EACE3C,QAAQ,GAAG,EAAX;AAEFpG,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACAA,IAAAA,OAAO,CAAC6K,KAAR,GAAgB,CAAhB;AACA,WAAO5K,IAAI,CAACwK,IAAL,CAAUnF,eAAV,EAA2Bc,QAA3B,EAAqCpG,OAArC,EAA8C8K,KAA9C,GAAsD,CAAtD,CAAP;AACD,GATD,C,CAWA;AACA;;;AACAhL,EAAAA,eAAe,CAACjC,SAAhB,CAA0BkN,WAA1B,GAAwC,UAAUlH,cAAV,EAA0BmH,KAA1B,EACWhL,OADX,EACoB;AAC1D,QAAIC,IAAI,GAAG,IAAX,CAD0D,CAG1D;AACA;;AACA,QAAI6D,UAAU,GAAG7D,IAAI,CAAC2D,aAAL,CAAmBC,cAAnB,CAAjB;AACA,QAAIK,MAAM,GAAG,IAAI7H,MAAJ,EAAb;AACA,QAAI4O,SAAS,GAAGnH,UAAU,CAACiH,WAAX,CAAuBC,KAAvB,EAA8BhL,OAA9B,EAAuCkE,MAAM,CAACjB,QAAP,EAAvC,CAAhB;AACAiB,IAAAA,MAAM,CAAChB,IAAP;AACD,GAVD;;AAYApD,EAAAA,eAAe,CAACjC,SAAhB,CAA0BqN,YAA1B,GAAyCpL,eAAe,CAACjC,SAAhB,CAA0BkN,WAAnE;;AAEAjL,EAAAA,eAAe,CAACjC,SAAhB,CAA0BsN,UAA1B,GAAuC,UAAUtH,cAAV,EAA0BmH,KAA1B,EAAiC;AACtE,QAAI/K,IAAI,GAAG,IAAX,CADsE,CAGtE;AACA;;AACA,QAAI6D,UAAU,GAAG7D,IAAI,CAAC2D,aAAL,CAAmBC,cAAnB,CAAjB;AACA,QAAIK,MAAM,GAAG,IAAI7H,MAAJ,EAAb;AACA,QAAI4O,SAAS,GAAGnH,UAAU,CAACsH,SAAX,CAAqBJ,KAArB,EAA4B9G,MAAM,CAACjB,QAAP,EAA5B,CAAhB;AACAiB,IAAAA,MAAM,CAAChB,IAAP;AACD,GATD,C,CAWA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAyH,EAAAA,iBAAiB,GAAG,UAAU9G,cAAV,EAA0BuC,QAA1B,EAAoCpG,OAApC,EAA6C;AAC/D,QAAIC,IAAI,GAAG,IAAX;AACAA,IAAAA,IAAI,CAAC4D,cAAL,GAAsBA,cAAtB;AACA5D,IAAAA,IAAI,CAACmG,QAAL,GAAgB3H,KAAK,CAAC4M,UAAN,CAAiBC,gBAAjB,CAAkClF,QAAlC,CAAhB;AACAnG,IAAAA,IAAI,CAACD,OAAL,GAAeA,OAAO,IAAI,EAA1B;AACD,GALD;;AAOA0K,EAAAA,MAAM,GAAG,UAAUhK,KAAV,EAAiB6K,iBAAjB,EAAoC;AAC3C,QAAItL,IAAI,GAAG,IAAX;AAEAA,IAAAA,IAAI,CAACuL,MAAL,GAAc9K,KAAd;AACAT,IAAAA,IAAI,CAACwL,kBAAL,GAA0BF,iBAA1B;AACAtL,IAAAA,IAAI,CAACyL,kBAAL,GAA0B,IAA1B;AACD,GAND;;AAQAtO,EAAAA,CAAC,CAACK,IAAF,CAAO,CAAC,SAAD,EAAY,KAAZ,EAAmB,OAAnB,EAA4B,OAA5B,EAAqCkO,MAAM,CAACC,QAA5C,CAAP,EAA8D,UAAU5B,MAAV,EAAkB;AAC9EU,IAAAA,MAAM,CAAC7M,SAAP,CAAiBmM,MAAjB,IAA2B,YAAY;AACrC,UAAI/J,IAAI,GAAG,IAAX,CADqC,CAGrC;;AACA,UAAIA,IAAI,CAACwL,kBAAL,CAAwBzL,OAAxB,CAAgC6L,QAApC,EACE,MAAM,IAAIrI,KAAJ,CAAU,iBAAiBwG,MAAjB,GAA0B,uBAApC,CAAN;;AAEF,UAAI,CAAC/J,IAAI,CAACyL,kBAAV,EAA8B;AAC5BzL,QAAAA,IAAI,CAACyL,kBAAL,GAA0BzL,IAAI,CAACuL,MAAL,CAAYM,wBAAZ,CACxB7L,IAAI,CAACwL,kBADmB,EACC;AACvB;AACA;AACAM,UAAAA,gBAAgB,EAAE9L,IAHK;AAIvB+L,UAAAA,YAAY,EAAE;AAJS,SADD,CAA1B;AAOD;;AAED,aAAO/L,IAAI,CAACyL,kBAAL,CAAwB1B,MAAxB,EAAgCM,KAAhC,CACLrK,IAAI,CAACyL,kBADA,EACoBnB,SADpB,CAAP;AAED,KAnBD;AAoBD,GArBD;;AAuBAG,EAAAA,MAAM,CAAC7M,SAAP,CAAiBoO,YAAjB,GAAgC,YAAY;AAC1C,WAAO,KAAKR,kBAAL,CAAwBzL,OAAxB,CAAgCkM,SAAvC;AACD,GAFD,C,CAIA;AACA;AACA;;;AAEAxB,EAAAA,MAAM,CAAC7M,SAAP,CAAiBsO,cAAjB,GAAkC,UAAUC,GAAV,EAAe;AAC/C,QAAInM,IAAI,GAAG,IAAX;AACA,QAAI6D,UAAU,GAAG7D,IAAI,CAACwL,kBAAL,CAAwB5H,cAAzC;AACA,WAAOpF,KAAK,CAAC4M,UAAN,CAAiBc,cAAjB,CAAgClM,IAAhC,EAAsCmM,GAAtC,EAA2CtI,UAA3C,CAAP;AACD,GAJD,C,CAMA;AACA;AACA;;;AACA4G,EAAAA,MAAM,CAAC7M,SAAP,CAAiBwO,kBAAjB,GAAsC,YAAY;AAChD,QAAIpM,IAAI,GAAG,IAAX;AACA,WAAOA,IAAI,CAACwL,kBAAL,CAAwB5H,cAA/B;AACD,GAHD;;AAKA6G,EAAAA,MAAM,CAAC7M,SAAP,CAAiByO,OAAjB,GAA2B,UAAUC,SAAV,EAAqB;AAC9C,QAAItM,IAAI,GAAG,IAAX;AACA,WAAOyF,eAAe,CAAC8G,0BAAhB,CAA2CvM,IAA3C,EAAiDsM,SAAjD,CAAP;AACD,GAHD;;AAKA7B,EAAAA,MAAM,CAAC7M,SAAP,CAAiB4O,cAAjB,GAAkC,UAAUF,SAAV,EAAmC;AAAA,QAAdvM,OAAc,uEAAJ,EAAI;AACnE,QAAIC,IAAI,GAAG,IAAX;AACA,QAAIyM,OAAO,GAAG,CACZ,SADY,EAEZ,OAFY,EAGZ,WAHY,EAIZ,SAJY,EAKZ,WALY,EAMZ,SANY,EAOZ,SAPY,CAAd;;AASA,QAAIC,OAAO,GAAGjH,eAAe,CAACkH,kCAAhB,CAAmDL,SAAnD,CAAd;;AAEA,QAAIM,aAAa,GAAGN,SAAS,CAACO,YAAV,GAAyB,SAAzB,GAAqC,gBAAzD;AACAD,IAAAA,aAAa,IAAI,WAAjB;AACAH,IAAAA,OAAO,CAACvL,OAAR,CAAgB,UAAU6I,MAAV,EAAkB;AAChC,UAAIuC,SAAS,CAACvC,MAAD,CAAT,IAAqB,OAAOuC,SAAS,CAACvC,MAAD,CAAhB,IAA4B,UAArD,EAAiE;AAC/DuC,QAAAA,SAAS,CAACvC,MAAD,CAAT,GAAoBzJ,MAAM,CAACyB,eAAP,CAAuBuK,SAAS,CAACvC,MAAD,CAAhC,EAA0CA,MAAM,GAAG6C,aAAnD,CAApB;AACD;AACF,KAJD;AAMA,WAAO5M,IAAI,CAACuL,MAAL,CAAYuB,eAAZ,CACL9M,IAAI,CAACwL,kBADA,EACoBkB,OADpB,EAC6BJ,SAD7B,EACwCvM,OAAO,CAACgN,oBADhD,CAAP;AAED,GAvBD;;AAyBAlN,EAAAA,eAAe,CAACjC,SAAhB,CAA0BiO,wBAA1B,GAAqD,UACjDP,iBADiD,EAC9BvL,OAD8B,EACrB;AAC9B,QAAIC,IAAI,GAAG,IAAX;AACAD,IAAAA,OAAO,GAAG5C,CAAC,CAAC6P,IAAF,CAAOjN,OAAO,IAAI,EAAlB,EAAsB,kBAAtB,EAA0C,cAA1C,CAAV;AAEA,QAAI8D,UAAU,GAAG7D,IAAI,CAAC2D,aAAL,CAAmB2H,iBAAiB,CAAC1H,cAArC,CAAjB;AACA,QAAIqJ,aAAa,GAAG3B,iBAAiB,CAACvL,OAAtC;AACA,QAAIW,YAAY,GAAG;AACjBwM,MAAAA,IAAI,EAAED,aAAa,CAACC,IADH;AAEjBtC,MAAAA,KAAK,EAAEqC,aAAa,CAACrC,KAFJ;AAGjBuC,MAAAA,IAAI,EAAEF,aAAa,CAACE,IAHH;AAIjBC,MAAAA,UAAU,EAAEH,aAAa,CAACI,MAAd,IAAwBJ,aAAa,CAACG,UAJjC;AAKjBE,MAAAA,cAAc,EAAEL,aAAa,CAACK;AALb,KAAnB,CAN8B,CAc9B;;AACA,QAAIL,aAAa,CAACrB,QAAlB,EAA4B;AAC1BlL,MAAAA,YAAY,CAAC6M,eAAb,GAA+B,CAAC,CAAhC;AACD;;AAED,QAAIC,QAAQ,GAAG3J,UAAU,CAAC2G,IAAX,CACbhL,YAAY,CAAC8L,iBAAiB,CAACnF,QAAnB,EAA6BlH,0BAA7B,CADC,EAEbyB,YAFa,CAAf,CAnB8B,CAuB9B;;AACA,QAAIuM,aAAa,CAACrB,QAAlB,EAA4B;AAC1B;AACA4B,MAAAA,QAAQ,CAACC,aAAT,CAAuB,UAAvB,EAAmC,IAAnC,EAF0B,CAG1B;AACA;;AACAD,MAAAA,QAAQ,CAACC,aAAT,CAAuB,WAAvB,EAAoC,IAApC,EAL0B,CAO1B;AACA;AACA;AACA;AACA;;AACA,UAAInC,iBAAiB,CAAC1H,cAAlB,KAAqC8J,gBAArC,IACApC,iBAAiB,CAACnF,QAAlB,CAA2BwH,EAD/B,EACmC;AACjCH,QAAAA,QAAQ,CAACC,aAAT,CAAuB,aAAvB,EAAsC,IAAtC;AACD;AACF;;AAED,QAAI,OAAOR,aAAa,CAACW,SAArB,KAAmC,WAAvC,EAAoD;AAClDJ,MAAAA,QAAQ,GAAGA,QAAQ,CAACK,SAAT,CAAmBZ,aAAa,CAACW,SAAjC,CAAX;AACD;;AACD,QAAI,OAAOX,aAAa,CAACa,IAArB,KAA8B,WAAlC,EAA+C;AAC7CN,MAAAA,QAAQ,GAAGA,QAAQ,CAACM,IAAT,CAAcb,aAAa,CAACa,IAA5B,CAAX;AACD;;AAED,WAAO,IAAIC,iBAAJ,CAAsBP,QAAtB,EAAgClC,iBAAhC,EAAmDvL,OAAnD,CAAP;AACD,GAnDD;;AAqDA,MAAIgO,iBAAiB,GAAG,UAAUP,QAAV,EAAoBlC,iBAApB,EAAuCvL,OAAvC,EAAgD;AACtE,QAAIC,IAAI,GAAG,IAAX;AACAD,IAAAA,OAAO,GAAG5C,CAAC,CAAC6P,IAAF,CAAOjN,OAAO,IAAI,EAAlB,EAAsB,kBAAtB,EAA0C,cAA1C,CAAV;AAEAC,IAAAA,IAAI,CAACgO,SAAL,GAAiBR,QAAjB;AACAxN,IAAAA,IAAI,CAACwL,kBAAL,GAA0BF,iBAA1B,CALsE,CAMtE;AACA;;AACAtL,IAAAA,IAAI,CAACiO,iBAAL,GAAyBlO,OAAO,CAAC+L,gBAAR,IAA4B9L,IAArD;;AACA,QAAID,OAAO,CAACgM,YAAR,IAAwBT,iBAAiB,CAACvL,OAAlB,CAA0BkM,SAAtD,EAAiE;AAC/DjM,MAAAA,IAAI,CAACkO,UAAL,GAAkBzI,eAAe,CAAC0I,aAAhB,CAChB7C,iBAAiB,CAACvL,OAAlB,CAA0BkM,SADV,CAAlB;AAED,KAHD,MAGO;AACLjM,MAAAA,IAAI,CAACkO,UAAL,GAAkB,IAAlB;AACD;;AAEDlO,IAAAA,IAAI,CAACoO,iBAAL,GAAyBhS,MAAM,CAACsH,IAAP,CAAY8J,QAAQ,CAACa,KAAT,CAAe/Q,IAAf,CAAoBkQ,QAApB,CAAZ,CAAzB;AACAxN,IAAAA,IAAI,CAACsO,WAAL,GAAmB,IAAI7I,eAAe,CAAC8I,MAApB,EAAnB;AACD,GAlBD;;AAoBApR,EAAAA,CAAC,CAACoJ,MAAF,CAASwH,iBAAiB,CAACnQ,SAA3B,EAAsC;AACpC;AACA;AACA4Q,IAAAA,qBAAqB,EAAE,YAAY;AACjC,YAAMxO,IAAI,GAAG,IAAb;AACA,aAAO,IAAIyO,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC3O,QAAAA,IAAI,CAACgO,SAAL,CAAeY,IAAf,CAAoB,CAAC5M,GAAD,EAAMa,GAAN,KAAc;AAChC,cAAIb,GAAJ,EAAS;AACP2M,YAAAA,MAAM,CAAC3M,GAAD,CAAN;AACD,WAFD,MAEO;AACL0M,YAAAA,OAAO,CAAC7L,GAAD,CAAP;AACD;AACF,SAND;AAOD,OARM,CAAP;AASD,KAdmC;AAgBpC;AACA;AACAgM,IAAAA,kBAAkB,EAAE;AAAA,sCAAkB;AACpC,YAAI7O,IAAI,GAAG,IAAX;;AAEA,eAAO,IAAP,EAAa;AACX,cAAI6C,GAAG,iBAAS7C,IAAI,CAACwO,qBAAL,EAAT,CAAP;AAEA,cAAI,CAAC3L,GAAL,EAAU,OAAO,IAAP;AACVA,UAAAA,GAAG,GAAGrD,YAAY,CAACqD,GAAD,EAAM3E,0BAAN,CAAlB;;AAEA,cAAI,CAAC8B,IAAI,CAACwL,kBAAL,CAAwBzL,OAAxB,CAAgC6L,QAAjC,IAA6CzO,CAAC,CAAC2D,GAAF,CAAM+B,GAAN,EAAW,KAAX,CAAjD,EAAoE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAI7C,IAAI,CAACsO,WAAL,CAAiBxN,GAAjB,CAAqB+B,GAAG,CAAC+C,GAAzB,CAAJ,EAAmC;;AACnC5F,YAAAA,IAAI,CAACsO,WAAL,CAAiBQ,GAAjB,CAAqBjM,GAAG,CAAC+C,GAAzB,EAA8B,IAA9B;AACD;;AAED,cAAI5F,IAAI,CAACkO,UAAT,EACErL,GAAG,GAAG7C,IAAI,CAACkO,UAAL,CAAgBrL,GAAhB,CAAN;AAEF,iBAAOA,GAAP;AACD;AACF,OAzBmB;AAAA,KAlBgB;AA6CpC;AACA;AACA;AACAkM,IAAAA,6BAA6B,EAAE,UAAUC,SAAV,EAAqB;AAClD,YAAMhP,IAAI,GAAG,IAAb;;AACA,UAAI,CAACgP,SAAL,EAAgB;AACd,eAAOhP,IAAI,CAAC6O,kBAAL,EAAP;AACD;;AACD,YAAMI,iBAAiB,GAAGjP,IAAI,CAAC6O,kBAAL,EAA1B;;AACA,YAAMK,UAAU,GAAG,IAAI3L,KAAJ,CAAU,6CAAV,CAAnB;AACA,YAAM4L,cAAc,GAAG,IAAIV,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtD,cAAMS,KAAK,GAAGC,UAAU,CAAC,MAAM;AAC7BV,UAAAA,MAAM,CAACO,UAAD,CAAN;AACD,SAFuB,EAErBF,SAFqB,CAAxB;AAGD,OAJsB,CAAvB;AAKA,aAAOP,OAAO,CAACa,IAAR,CAAa,CAACL,iBAAD,EAAoBE,cAApB,CAAb,EACJlJ,KADI,CACGjE,GAAD,IAAS;AACd,YAAIA,GAAG,KAAKkN,UAAZ,EAAwB;AACtBlP,UAAAA,IAAI,CAACsD,KAAL;AACD;;AACD,cAAMtB,GAAN;AACD,OANI,CAAP;AAOD,KAnEmC;AAqEpCuN,IAAAA,WAAW,EAAE,YAAY;AACvB,UAAIvP,IAAI,GAAG,IAAX;AACA,aAAOA,IAAI,CAAC6O,kBAAL,GAA0BvM,KAA1B,EAAP;AACD,KAxEmC;AA0EpCpB,IAAAA,OAAO,EAAE,UAAU4B,QAAV,EAAoB0M,OAApB,EAA6B;AACpC,UAAIxP,IAAI,GAAG,IAAX,CADoC,CAGpC;;AACAA,MAAAA,IAAI,CAACyP,OAAL,GAJoC,CAMpC;AACA;AACA;;;AACA,UAAI1E,KAAK,GAAG,CAAZ;;AACA,aAAO,IAAP,EAAa;AACX,YAAIlI,GAAG,GAAG7C,IAAI,CAACuP,WAAL,EAAV;;AACA,YAAI,CAAC1M,GAAL,EAAU;AACVC,QAAAA,QAAQ,CAAC4M,IAAT,CAAcF,OAAd,EAAuB3M,GAAvB,EAA4BkI,KAAK,EAAjC,EAAqC/K,IAAI,CAACiO,iBAA1C;AACD;AACF,KAzFmC;AA2FpC;AACA5Q,IAAAA,GAAG,EAAE,UAAUyF,QAAV,EAAoB0M,OAApB,EAA6B;AAChC,UAAIxP,IAAI,GAAG,IAAX;AACA,UAAI2P,GAAG,GAAG,EAAV;AACA3P,MAAAA,IAAI,CAACkB,OAAL,CAAa,UAAU2B,GAAV,EAAekI,KAAf,EAAsB;AACjC4E,QAAAA,GAAG,CAACC,IAAJ,CAAS9M,QAAQ,CAAC4M,IAAT,CAAcF,OAAd,EAAuB3M,GAAvB,EAA4BkI,KAA5B,EAAmC/K,IAAI,CAACiO,iBAAxC,CAAT;AACD,OAFD;AAGA,aAAO0B,GAAP;AACD,KAnGmC;AAqGpCF,IAAAA,OAAO,EAAE,YAAY;AACnB,UAAIzP,IAAI,GAAG,IAAX,CADmB,CAGnB;;AACAA,MAAAA,IAAI,CAACgO,SAAL,CAAe6B,MAAf;;AAEA7P,MAAAA,IAAI,CAACsO,WAAL,GAAmB,IAAI7I,eAAe,CAAC8I,MAApB,EAAnB;AACD,KA5GmC;AA8GpC;AACAjL,IAAAA,KAAK,EAAE,YAAY;AACjB,UAAItD,IAAI,GAAG,IAAX;;AAEAA,MAAAA,IAAI,CAACgO,SAAL,CAAe1K,KAAf;AACD,KAnHmC;AAqHpCuH,IAAAA,KAAK,EAAE,YAAY;AACjB,UAAI7K,IAAI,GAAG,IAAX;AACA,aAAOA,IAAI,CAAC3C,GAAL,CAASF,CAAC,CAAC2S,QAAX,CAAP;AACD,KAxHmC;AA0HpCzB,IAAAA,KAAK,EAAE,YAAY;AACjB,UAAIrO,IAAI,GAAG,IAAX;AACA,aAAOA,IAAI,CAACoO,iBAAL,GAAyBnL,IAAzB,EAAP;AACD,KA7HmC;AA+HpC;AACA8M,IAAAA,aAAa,EAAE,UAAUrD,OAAV,EAAmB;AAChC,UAAI1M,IAAI,GAAG,IAAX;;AACA,UAAI0M,OAAJ,EAAa;AACX,eAAO1M,IAAI,CAAC6K,KAAL,EAAP;AACD,OAFD,MAEO;AACL,YAAImF,OAAO,GAAG,IAAIvK,eAAe,CAAC8I,MAApB,EAAd;AACAvO,QAAAA,IAAI,CAACkB,OAAL,CAAa,UAAU2B,GAAV,EAAe;AAC1BmN,UAAAA,OAAO,CAAClB,GAAR,CAAYjM,GAAG,CAAC+C,GAAhB,EAAqB/C,GAArB;AACD,SAFD;AAGA,eAAOmN,OAAP;AACD;AACF;AA3ImC,GAAtC;;AA8IAjC,EAAAA,iBAAiB,CAACnQ,SAAlB,CAA4B8N,MAAM,CAACC,QAAnC,IAA+C,YAAY;AACzD,QAAI3L,IAAI,GAAG,IAAX,CADyD,CAGzD;;AACAA,IAAAA,IAAI,CAACyP,OAAL;;AAEA,WAAO;AACLb,MAAAA,IAAI,GAAG;AACL,cAAM/L,GAAG,GAAG7C,IAAI,CAACuP,WAAL,EAAZ;;AACA,eAAO1M,GAAG,GAAG;AACXpF,UAAAA,KAAK,EAAEoF;AADI,SAAH,GAEN;AACFoN,UAAAA,IAAI,EAAE;AADJ,SAFJ;AAKD;;AARI,KAAP;AAUD,GAhBD,C,CAkBA;AACA;AACA;AACA;AACA;AACA;;;AACApQ,EAAAA,eAAe,CAACjC,SAAhB,CAA0BsS,IAA1B,GAAiC,UAAU5E,iBAAV,EAA6B6E,WAA7B,EAA0CnB,SAA1C,EAAqD;AACpF,QAAIhP,IAAI,GAAG,IAAX;AACA,QAAI,CAACsL,iBAAiB,CAACvL,OAAlB,CAA0B6L,QAA/B,EACE,MAAM,IAAIrI,KAAJ,CAAU,iCAAV,CAAN;;AAEF,QAAI6M,MAAM,GAAGpQ,IAAI,CAAC6L,wBAAL,CAA8BP,iBAA9B,CAAb;;AAEA,QAAI+E,OAAO,GAAG,KAAd;AACA,QAAIC,MAAJ;;AACA,QAAIC,IAAI,GAAG,YAAY;AACrB,UAAI1N,GAAG,GAAG,IAAV;;AACA,aAAO,IAAP,EAAa;AACX,YAAIwN,OAAJ,EACE;;AACF,YAAI;AACFxN,UAAAA,GAAG,GAAGuN,MAAM,CAACrB,6BAAP,CAAqCC,SAArC,EAAgD1M,KAAhD,EAAN;AACD,SAFD,CAEE,OAAON,GAAP,EAAY;AACZ;AACA;AACA;AACA;AACAa,UAAAA,GAAG,GAAG,IAAN;AACD,SAXU,CAYX;AACA;;;AACA,YAAIwN,OAAJ,EACE;;AACF,YAAIxN,GAAJ,EAAS;AACP;AACA;AACA;AACA;AACAyN,UAAAA,MAAM,GAAGzN,GAAG,CAAC8K,EAAb;AACAwC,UAAAA,WAAW,CAACtN,GAAD,CAAX;AACD,SAPD,MAOO;AACL,cAAI2N,WAAW,GAAGrT,CAAC,CAACU,KAAF,CAAQyN,iBAAiB,CAACnF,QAA1B,CAAlB;;AACA,cAAImK,MAAJ,EAAY;AACVE,YAAAA,WAAW,CAAC7C,EAAZ,GAAiB;AAAC8C,cAAAA,GAAG,EAAEH;AAAN,aAAjB;AACD;;AACDF,UAAAA,MAAM,GAAGpQ,IAAI,CAAC6L,wBAAL,CAA8B,IAAInB,iBAAJ,CACrCY,iBAAiB,CAAC1H,cADmB,EAErC4M,WAFqC,EAGrClF,iBAAiB,CAACvL,OAHmB,CAA9B,CAAT,CALK,CASL;AACA;AACA;;AACAO,UAAAA,MAAM,CAAC+O,UAAP,CAAkBkB,IAAlB,EAAwB,GAAxB;AACA;AACD;AACF;AACF,KAzCD;;AA2CAjQ,IAAAA,MAAM,CAACoQ,KAAP,CAAaH,IAAb;AAEA,WAAO;AACL9M,MAAAA,IAAI,EAAE,YAAY;AAChB4M,QAAAA,OAAO,GAAG,IAAV;AACAD,QAAAA,MAAM,CAAC9M,KAAP;AACD;AAJI,KAAP;AAMD,GA5DD;;AA8DAzD,EAAAA,eAAe,CAACjC,SAAhB,CAA0BkP,eAA1B,GAA4C,UACxCxB,iBADwC,EACrBoB,OADqB,EACZJ,SADY,EACDS,oBADC,EACqB;AAC/D,QAAI/M,IAAI,GAAG,IAAX;;AAEA,QAAIsL,iBAAiB,CAACvL,OAAlB,CAA0B6L,QAA9B,EAAwC;AACtC,aAAO5L,IAAI,CAAC2Q,uBAAL,CAA6BrF,iBAA7B,EAAgDoB,OAAhD,EAAyDJ,SAAzD,CAAP;AACD,KAL8D,CAO/D;AACA;;;AACA,UAAMsE,aAAa,GAAGtF,iBAAiB,CAACvL,OAAlB,CAA0BqN,UAA1B,IAAwC9B,iBAAiB,CAACvL,OAAlB,CAA0BsN,MAAxF;;AACA,QAAIuD,aAAa,KACZA,aAAa,CAAChL,GAAd,KAAsB,CAAtB,IACAgL,aAAa,CAAChL,GAAd,KAAsB,KAFV,CAAjB,EAEmC;AACjC,YAAMrC,KAAK,CAAC,sDAAD,CAAX;AACD;;AAED,QAAIsN,UAAU,GAAG/R,KAAK,CAACgS,SAAN,CACf3T,CAAC,CAACoJ,MAAF,CAAS;AAACmG,MAAAA,OAAO,EAAEA;AAAV,KAAT,EAA6BpB,iBAA7B,CADe,CAAjB;AAGA,QAAIyF,WAAJ,EAAiBC,aAAjB;AACA,QAAIC,WAAW,GAAG,KAAlB,CApB+D,CAsB/D;AACA;AACA;;AACA3Q,IAAAA,MAAM,CAAC4Q,gBAAP,CAAwB,YAAY;AAClC,UAAI/T,CAAC,CAAC2D,GAAF,CAAMd,IAAI,CAACC,oBAAX,EAAiC4Q,UAAjC,CAAJ,EAAkD;AAChDE,QAAAA,WAAW,GAAG/Q,IAAI,CAACC,oBAAL,CAA0B4Q,UAA1B,CAAd;AACD,OAFD,MAEO;AACLI,QAAAA,WAAW,GAAG,IAAd,CADK,CAEL;;AACAF,QAAAA,WAAW,GAAG,IAAII,kBAAJ,CAAuB;AACnCzE,UAAAA,OAAO,EAAEA,OAD0B;AAEnC0E,UAAAA,MAAM,EAAE,YAAY;AAClB,mBAAOpR,IAAI,CAACC,oBAAL,CAA0B4Q,UAA1B,CAAP;AACAG,YAAAA,aAAa,CAACvN,IAAd;AACD;AALkC,SAAvB,CAAd;AAOAzD,QAAAA,IAAI,CAACC,oBAAL,CAA0B4Q,UAA1B,IAAwCE,WAAxC;AACD;AACF,KAfD;;AAiBA,QAAIM,aAAa,GAAG,IAAIC,aAAJ,CAAkBP,WAAlB,EAClBzE,SADkB,EAElBS,oBAFkB,CAApB;;AAKA,QAAIkE,WAAJ,EAAiB;AACf,UAAIM,OAAJ,EAAaC,MAAb;;AACA,UAAIC,WAAW,GAAGtU,CAAC,CAACuU,GAAF,CAAM,CACtB,YAAY;AACV;AACA;AACA;AACA,eAAO1R,IAAI,CAAC0B,YAAL,IAAqB,CAACgL,OAAtB,IACL,CAACJ,SAAS,CAACqF,qBADb;AAED,OAPqB,EAOnB,YAAY;AACb;AACA;AACA,YAAI;AACFJ,UAAAA,OAAO,GAAG,IAAIK,SAAS,CAACC,OAAd,CAAsBvG,iBAAiB,CAACnF,QAAxC,CAAV;AACA,iBAAO,IAAP;AACD,SAHD,CAGE,OAAOZ,CAAP,EAAU;AACV;AACA;AACA,iBAAO,KAAP;AACD;AACF,OAlBqB,EAkBnB,YAAY;AACb;AACA,eAAOuM,kBAAkB,CAACC,eAAnB,CAAmCzG,iBAAnC,EAAsDiG,OAAtD,CAAP;AACD,OArBqB,EAqBnB,YAAY;AACb;AACA;AACA,YAAI,CAACjG,iBAAiB,CAACvL,OAAlB,CAA0BmN,IAA/B,EACE,OAAO,IAAP;;AACF,YAAI;AACFsE,UAAAA,MAAM,GAAG,IAAII,SAAS,CAACI,MAAd,CAAqB1G,iBAAiB,CAACvL,OAAlB,CAA0BmN,IAA/C,CAAT;AACA,iBAAO,IAAP;AACD,SAHD,CAGE,OAAO3H,CAAP,EAAU;AACV;AACA;AACA,iBAAO,KAAP;AACD;AACF,OAlCqB,CAAN,EAkCZ,UAAU0M,CAAV,EAAa;AAAE,eAAOA,CAAC,EAAR;AAAa,OAlChB,CAAlB,CAFe,CAoCuB;;;AAEtC,UAAIC,WAAW,GAAGT,WAAW,GAAGK,kBAAH,GAAwBK,oBAArD;AACAnB,MAAAA,aAAa,GAAG,IAAIkB,WAAJ,CAAgB;AAC9B5G,QAAAA,iBAAiB,EAAEA,iBADW;AAE9B8G,QAAAA,WAAW,EAAEpS,IAFiB;AAG9B+Q,QAAAA,WAAW,EAAEA,WAHiB;AAI9BrE,QAAAA,OAAO,EAAEA,OAJqB;AAK9B6E,QAAAA,OAAO,EAAEA,OALqB;AAKX;AACnBC,QAAAA,MAAM,EAAEA,MANsB;AAMb;AACjBG,QAAAA,qBAAqB,EAAErF,SAAS,CAACqF;AAPH,OAAhB,CAAhB,CAvCe,CAiDf;;AACAZ,MAAAA,WAAW,CAACsB,cAAZ,GAA6BrB,aAA7B;AACD,KAlG8D,CAoG/D;;;AACAD,IAAAA,WAAW,CAACuB,2BAAZ,CAAwCjB,aAAxC;AAEA,WAAOA,aAAP;AACD,GAzGD,C,CA2GA;AACA;AACA;AACA;AACA;;;AAEAkB,EAAAA,SAAS,GAAG,UAAUjH,iBAAV,EAA6BkH,cAA7B,EAA6C;AACvD,QAAIC,SAAS,GAAG,EAAhB;AACAC,IAAAA,cAAc,CAACpH,iBAAD,EAAoB,UAAUqH,OAAV,EAAmB;AACnDF,MAAAA,SAAS,CAAC7C,IAAV,CAAerL,SAAS,CAACqO,qBAAV,CAAgCC,MAAhC,CACbF,OADa,EACJH,cADI,CAAf;AAED,KAHa,CAAd;AAKA,WAAO;AACL/O,MAAAA,IAAI,EAAE,YAAY;AAChBtG,QAAAA,CAAC,CAACK,IAAF,CAAOiV,SAAP,EAAkB,UAAUK,QAAV,EAAoB;AACpCA,UAAAA,QAAQ,CAACrP,IAAT;AACD,SAFD;AAGD;AALI,KAAP;AAOD,GAdD;;AAgBAiP,EAAAA,cAAc,GAAG,UAAUpH,iBAAV,EAA6ByH,eAA7B,EAA8C;AAC7D,QAAIrV,GAAG,GAAG;AAACmG,MAAAA,UAAU,EAAEyH,iBAAiB,CAAC1H;AAA/B,KAAV;;AACA,QAAIyC,WAAW,GAAGZ,eAAe,CAACa,qBAAhB,CAChBgF,iBAAiB,CAACnF,QADF,CAAlB;;AAEA,QAAIE,WAAJ,EAAiB;AACflJ,MAAAA,CAAC,CAACK,IAAF,CAAO6I,WAAP,EAAoB,UAAUV,EAAV,EAAc;AAChCoN,QAAAA,eAAe,CAAC5V,CAAC,CAACoJ,MAAF,CAAS;AAACZ,UAAAA,EAAE,EAAEA;AAAL,SAAT,EAAmBjI,GAAnB,CAAD,CAAf;AACD,OAFD;;AAGAqV,MAAAA,eAAe,CAAC5V,CAAC,CAACoJ,MAAF,CAAS;AAACS,QAAAA,cAAc,EAAE,IAAjB;AAAuBrB,QAAAA,EAAE,EAAE;AAA3B,OAAT,EAA2CjI,GAA3C,CAAD,CAAf;AACD,KALD,MAKO;AACLqV,MAAAA,eAAe,CAACrV,GAAD,CAAf;AACD,KAX4D,CAY7D;;;AACAqV,IAAAA,eAAe,CAAC;AAAE5L,MAAAA,YAAY,EAAE;AAAhB,KAAD,CAAf;AACD,GAdD,C,CAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAtH,EAAAA,eAAe,CAACjC,SAAhB,CAA0B+S,uBAA1B,GAAoD,UAChDrF,iBADgD,EAC7BoB,OAD6B,EACpBJ,SADoB,EACT;AACzC,QAAItM,IAAI,GAAG,IAAX,CADyC,CAGzC;AACA;;AACA,QAAK0M,OAAO,IAAI,CAACJ,SAAS,CAAC0G,WAAvB,IACC,CAACtG,OAAD,IAAY,CAACJ,SAAS,CAAC2G,KAD5B,EACoC;AAClC,YAAM,IAAI1P,KAAJ,CAAU,uBAAuBmJ,OAAO,GAAG,SAAH,GAAe,WAA7C,IACE,6BADF,IAEGA,OAAO,GAAG,aAAH,GAAmB,OAF7B,IAEwC,WAFlD,CAAN;AAGD;;AAED,WAAO1M,IAAI,CAACkQ,IAAL,CAAU5E,iBAAV,EAA6B,UAAUzI,GAAV,EAAe;AACjD,UAAI8C,EAAE,GAAG9C,GAAG,CAAC+C,GAAb;AACA,aAAO/C,GAAG,CAAC+C,GAAX,CAFiD,CAGjD;;AACA,aAAO/C,GAAG,CAAC8K,EAAX;;AACA,UAAIjB,OAAJ,EAAa;AACXJ,QAAAA,SAAS,CAAC0G,WAAV,CAAsBrN,EAAtB,EAA0B9C,GAA1B,EAA+B,IAA/B;AACD,OAFD,MAEO;AACLyJ,QAAAA,SAAS,CAAC2G,KAAV,CAAgBtN,EAAhB,EAAoB9C,GAApB;AACD;AACF,KAVM,CAAP;AAWD,GAxBD,C,CA0BA;AACA;AACA;;;AACAvG,EAAAA,cAAc,CAAC4W,cAAf,GAAgChX,OAAO,CAACyB,SAAxC;AAEArB,EAAAA,cAAc,CAAC6W,UAAf,GAA4BtT,eAA5B","sourcesContent":["import { normalizeProjection } from \"./mongo_utils\";\n\n/**\n * Provide a synchronous Collection API using fibers, backed by\n * MongoDB.  This is only for use on the server, and mostly identical\n * to the client API.\n *\n * NOTE: the public API methods must be run within a fiber. If you call\n * these outside of a fiber they will explode!\n */\n\nconst path = require(\"path\");\n\nvar MongoDB = NpmModuleMongodb;\nvar Future = Npm.require('fibers/future');\nimport { DocFetcher } from \"./doc_fetcher.js\";\n\nMongoInternals = {};\n\nMongoInternals.NpmModules = {\n  mongodb: {\n    version: NpmModuleMongodbVersion,\n    module: MongoDB\n  }\n};\n\n// Older version of what is now available via\n// MongoInternals.NpmModules.mongodb.module.  It was never documented, but\n// people do use it.\n// XXX COMPAT WITH 1.0.3.2\nMongoInternals.NpmModule = MongoDB;\n\nconst FILE_ASSET_SUFFIX = 'Asset';\nconst ASSETS_FOLDER = 'assets';\nconst APP_FOLDER = 'app';\n\n// This is used to add or remove EJSON from the beginning of everything nested\n// inside an EJSON custom type. It should only be called on pure JSON!\nvar replaceNames = function (filter, thing) {\n  if (typeof thing === \"object\" && thing !== null) {\n    if (_.isArray(thing)) {\n      return _.map(thing, _.bind(replaceNames, null, filter));\n    }\n    var ret = {};\n    _.each(thing, function (value, key) {\n      ret[filter(key)] = replaceNames(filter, value);\n    });\n    return ret;\n  }\n  return thing;\n};\n\n// Ensure that EJSON.clone keeps a Timestamp as a Timestamp (instead of just\n// doing a structural clone).\n// XXX how ok is this? what if there are multiple copies of MongoDB loaded?\nMongoDB.Timestamp.prototype.clone = function () {\n  // Timestamps should be immutable.\n  return this;\n};\n\nvar makeMongoLegal = function (name) { return \"EJSON\" + name; };\nvar unmakeMongoLegal = function (name) { return name.substr(5); };\n\nvar replaceMongoAtomWithMeteor = function (document) {\n  if (document instanceof MongoDB.Binary) {\n    var buffer = document.value(true);\n    return new Uint8Array(buffer);\n  }\n  if (document instanceof MongoDB.ObjectID) {\n    return new Mongo.ObjectID(document.toHexString());\n  }\n  if (document instanceof MongoDB.Decimal128) {\n    return Decimal(document.toString());\n  }\n  if (document[\"EJSON$type\"] && document[\"EJSON$value\"] && _.size(document) === 2) {\n    return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document));\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  return undefined;\n};\n\nvar replaceMeteorAtomWithMongo = function (document) {\n  if (EJSON.isBinary(document)) {\n    // This does more copies than we'd like, but is necessary because\n    // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually\n    // serialize it correctly).\n    return new MongoDB.Binary(Buffer.from(document));\n  }\n  if (document instanceof Mongo.ObjectID) {\n    return new MongoDB.ObjectID(document.toHexString());\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  if (document instanceof Decimal) {\n    return MongoDB.Decimal128.fromString(document.toString());\n  }\n  if (EJSON._isCustomType(document)) {\n    return replaceNames(makeMongoLegal, EJSON.toJSONValue(document));\n  }\n  // It is not ordinarily possible to stick dollar-sign keys into mongo\n  // so we don't bother checking for things that need escaping at this time.\n  return undefined;\n};\n\nvar replaceTypes = function (document, atomTransformer) {\n  if (typeof document !== 'object' || document === null)\n    return document;\n\n  var replacedTopLevelAtom = atomTransformer(document);\n  if (replacedTopLevelAtom !== undefined)\n    return replacedTopLevelAtom;\n\n  var ret = document;\n  _.each(document, function (val, key) {\n    var valReplaced = replaceTypes(val, atomTransformer);\n    if (val !== valReplaced) {\n      // Lazy clone. Shallow copy.\n      if (ret === document)\n        ret = _.clone(document);\n      ret[key] = valReplaced;\n    }\n  });\n  return ret;\n};\n\n\nMongoConnection = function (url, options) {\n  var self = this;\n  options = options || {};\n  self._observeMultiplexers = {};\n  self._onFailoverHook = new Hook;\n\n  const userOptions = {\n    ...(Mongo._connectionOptions || {}),\n    ...(Meteor.settings?.packages?.mongo?.options || {})\n  };\n\n  var mongoOptions = Object.assign({\n    ignoreUndefined: true,\n  }, userOptions);\n\n\n\n  // Internally the oplog connections specify their own maxPoolSize\n  // which we don't want to overwrite with any user defined value\n  if (_.has(options, 'maxPoolSize')) {\n    // If we just set this for \"server\", replSet will override it. If we just\n    // set it for replSet, it will be ignored if we're not using a replSet.\n    mongoOptions.maxPoolSize = options.maxPoolSize;\n  }\n\n  // Transform options like \"tlsCAFileAsset\": \"filename.pem\" into\n  // \"tlsCAFile\": \"/<fullpath>/filename.pem\"\n  Object.entries(mongoOptions || {})\n    .filter(([key]) => key && key.endsWith(FILE_ASSET_SUFFIX))\n    .forEach(([key, value]) => {\n      const optionName = key.replace(FILE_ASSET_SUFFIX, '');\n      mongoOptions[optionName] = path.join(Assets.getServerDir(),\n        ASSETS_FOLDER, APP_FOLDER, value);\n      delete mongoOptions[key];\n    });\n\n  self.db = null;\n  // We keep track of the ReplSet's primary, so that we can trigger hooks when\n  // it changes.  The Node driver's joined callback seems to fire way too\n  // often, which is why we need to track it ourselves.\n  self._primary = null;\n  self._oplogHandle = null;\n  self._docFetcher = null;\n\n\n  var connectFuture = new Future;\n  new MongoDB.MongoClient(\n    url,\n    mongoOptions\n  ).connect(\n    Meteor.bindEnvironment(\n      function (err, client) {\n        if (err) {\n          throw err;\n        }\n\n        var db = client.db();\n        try {\n          const helloDocument = db.admin().command({hello: 1}).await();\n          // First, figure out what the current primary is, if any.\n          if (helloDocument.primary) {\n            self._primary = helloDocument.primary;\n          }\n        }catch(_){\n          // ismaster command is supported on older mongodb versions\n          const isMasterDocument = db.admin().command({ismaster:1}).await();\n          // First, figure out what the current primary is, if any.\n          if (isMasterDocument.primary) {\n            self._primary = isMasterDocument.primary;\n          }\n        }\n\n        client.topology.on(\n          'joined', Meteor.bindEnvironment(function (kind, doc) {\n            if (kind === 'primary') {\n              if (doc.primary !== self._primary) {\n                self._primary = doc.primary;\n                self._onFailoverHook.each(function (callback) {\n                  callback();\n                  return true;\n                });\n              }\n            } else if (doc.me === self._primary) {\n              // The thing we thought was primary is now something other than\n              // primary.  Forget that we thought it was primary.  (This means\n              // that if a server stops being primary and then starts being\n              // primary again without another server becoming primary in the\n              // middle, we'll correctly count it as a failover.)\n              self._primary = null;\n            }\n          }));\n\n        // Allow the constructor to return.\n        connectFuture['return']({ client, db });\n      },\n      connectFuture.resolver()  // onException\n    )\n  );\n\n  // Wait for the connection to be successful (throws on failure) and assign the\n  // results (`client` and `db`) to `self`.\n  Object.assign(self, connectFuture.wait());\n\n  if (options.oplogUrl && ! Package['disable-oplog']) {\n    self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName);\n    self._docFetcher = new DocFetcher(self);\n  }\n};\n\nMongoConnection.prototype.close = function() {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"close called before Connection created?\");\n\n  // XXX probably untested\n  var oplogHandle = self._oplogHandle;\n  self._oplogHandle = null;\n  if (oplogHandle)\n    oplogHandle.stop();\n\n  // Use Future.wrap so that errors get thrown. This happens to\n  // work even outside a fiber since the 'close' method is not\n  // actually asynchronous.\n  Future.wrap(_.bind(self.client.close, self.client))(true).wait();\n};\n\n// Returns the Mongo Collection object; may yield.\nMongoConnection.prototype.rawCollection = function (collectionName) {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"rawCollection called before Connection created?\");\n\n  return self.db.collection(collectionName);\n};\n\nMongoConnection.prototype._createCappedCollection = function (\n    collectionName, byteSize, maxDocuments) {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"_createCappedCollection called before Connection created?\");\n\n  var future = new Future();\n  self.db.createCollection(\n    collectionName,\n    { capped: true, size: byteSize, max: maxDocuments },\n    future.resolver());\n  future.wait();\n};\n\n// This should be called synchronously with a write, to create a\n// transaction on the current write fence, if any. After we can read\n// the write, and after observers have been notified (or at least,\n// after the observer notifiers have added themselves to the write\n// fence), you should call 'committed()' on the object returned.\nMongoConnection.prototype._maybeBeginWrite = function () {\n  var fence = DDPServer._CurrentWriteFence.get();\n  if (fence) {\n    return fence.beginWrite();\n  } else {\n    return {committed: function () {}};\n  }\n};\n\n// Internal interface: adds a callback which is called when the Mongo primary\n// changes. Returns a stop handle.\nMongoConnection.prototype._onFailover = function (callback) {\n  return this._onFailoverHook.register(callback);\n};\n\n\n//////////// Public API //////////\n\n// The write methods block until the database has confirmed the write (it may\n// not be replicated or stable on disk, but one server has confirmed it) if no\n// callback is provided. If a callback is provided, then they call the callback\n// when the write is confirmed. They return nothing on success, and raise an\n// exception on failure.\n//\n// After making a write (with insert, update, remove), observers are\n// notified asynchronously. If you want to receive a callback once all\n// of the observer notifications have landed for your write, do the\n// writes inside a write fence (set DDPServer._CurrentWriteFence to a new\n// _WriteFence, and then set a callback on the write fence.)\n//\n// Since our execution environment is single-threaded, this is\n// well-defined -- a write \"has been made\" if it's returned, and an\n// observer \"has been notified\" if its callback has returned.\n\nvar writeCallback = function (write, refresh, callback) {\n  return function (err, result) {\n    if (! err) {\n      // XXX We don't have to run this on error, right?\n      try {\n        refresh();\n      } catch (refreshErr) {\n        if (callback) {\n          callback(refreshErr);\n          return;\n        } else {\n          throw refreshErr;\n        }\n      }\n    }\n    write.committed();\n    if (callback) {\n      callback(err, result);\n    } else if (err) {\n      throw err;\n    }\n  };\n};\n\nvar bindEnvironmentForWrite = function (callback) {\n  return Meteor.bindEnvironment(callback, \"Mongo write\");\n};\n\nMongoConnection.prototype._insert = function (collection_name, document,\n                                              callback) {\n  var self = this;\n\n  var sendError = function (e) {\n    if (callback)\n      return callback(e);\n    throw e;\n  };\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    sendError(e);\n    return;\n  }\n\n  if (!(LocalCollection._isPlainObject(document) &&\n        !EJSON._isCustomType(document))) {\n    sendError(new Error(\n      \"Only plain objects may be inserted into MongoDB\"));\n    return;\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({collection: collection_name, id: document._id });\n  };\n  callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n  try {\n    var collection = self.rawCollection(collection_name);\n    collection.insertOne(\n      replaceTypes(document, replaceMeteorAtomWithMongo),\n      {\n        safe: true,\n      }\n    ).then(({insertedId}) => {\n      callback(null, insertedId);\n    }).catch((e) => {\n      callback(e, null)\n    });\n  } catch (err) {\n    write.committed();\n    throw err;\n  }\n};\n\n// Cause queries that may be affected by the selector to poll in this write\n// fence.\nMongoConnection.prototype._refresh = function (collectionName, selector) {\n  var refreshKey = {collection: collectionName};\n  // If we know which documents we're removing, don't poll queries that are\n  // specific to other documents. (Note that multiple notifications here should\n  // not cause multiple polls, since all our listener is doing is enqueueing a\n  // poll.)\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);\n  if (specificIds) {\n    _.each(specificIds, function (id) {\n      Meteor.refresh(_.extend({id: id}, refreshKey));\n    });\n  } else {\n    Meteor.refresh(refreshKey);\n  }\n};\n\nMongoConnection.prototype._remove = function (collection_name, selector,\n                                              callback) {\n  var self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    if (callback) {\n      return callback(e);\n    } else {\n      throw e;\n    }\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    self._refresh(collection_name, selector);\n  };\n  callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n\n  try {\n    var collection = self.rawCollection(collection_name);\n    collection\n      .deleteMany(replaceTypes(selector, replaceMeteorAtomWithMongo), {\n        safe: true,\n      })\n      .then(({ deletedCount }) => {\n        callback(null, transformResult({ result : {modifiedCount : deletedCount} }).numberAffected);\n      }).catch((err) => {\n      callback(err);\n    });\n  } catch (err) {\n    write.committed();\n    throw err;\n  }\n};\n\nMongoConnection.prototype._dropCollection = function (collectionName, cb) {\n  var self = this;\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({collection: collectionName, id: null,\n                    dropCollection: true});\n  };\n  cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n\n  try {\n    var collection = self.rawCollection(collectionName);\n    collection.drop(cb);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\n// For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`\n// because it lets the test's fence wait for it to be complete.\nMongoConnection.prototype._dropDatabase = function (cb) {\n  var self = this;\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({ dropDatabase: true });\n  };\n  cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n\n  try {\n    self.db.dropDatabase(cb);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\nMongoConnection.prototype._update = function (collection_name, selector, mod,\n                                              options, callback) {\n  var self = this;\n\n  if (! callback && options instanceof Function) {\n    callback = options;\n    options = null;\n  }\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    if (callback) {\n      return callback(e);\n    } else {\n      throw e;\n    }\n  }\n\n  // explicit safety check. null and undefined can crash the mongo\n  // driver. Although the node driver and minimongo do 'support'\n  // non-object modifier in that they don't crash, they are not\n  // meaningful operations and do not do anything. Defensively throw an\n  // error here.\n  if (!mod || typeof mod !== 'object')\n    throw new Error(\"Invalid modifier. Modifier must be an object.\");\n\n  if (!(LocalCollection._isPlainObject(mod) &&\n        !EJSON._isCustomType(mod))) {\n    throw new Error(\n      \"Only plain objects may be used as replacement\" +\n        \" documents in MongoDB\");\n  }\n\n  if (!options) options = {};\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    self._refresh(collection_name, selector);\n  };\n  callback = writeCallback(write, refresh, callback);\n  try {\n    var collection = self.rawCollection(collection_name);\n    var mongoOpts = {safe: true};\n    // Add support for filtered positional operator\n    if (options.arrayFilters !== undefined) mongoOpts.arrayFilters = options.arrayFilters;\n    // explictly enumerate options that minimongo supports\n    if (options.upsert) mongoOpts.upsert = true;\n    if (options.multi) mongoOpts.multi = true;\n    // Lets you get a more more full result from MongoDB. Use with caution:\n    // might not work with C.upsert (as opposed to C.update({upsert:true}) or\n    // with simulated upsert.\n    if (options.fullResult) mongoOpts.fullResult = true;\n\n    var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo);\n    var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo);\n\n    var isModify = LocalCollection._isModificationMod(mongoMod);\n\n    if (options._forbidReplace && !isModify) {\n      var err = new Error(\"Invalid modifier. Replacements are forbidden.\");\n      if (callback) {\n        return callback(err);\n      } else {\n        throw err;\n      }\n    }\n\n    // We've already run replaceTypes/replaceMeteorAtomWithMongo on\n    // selector and mod.  We assume it doesn't matter, as far as\n    // the behavior of modifiers is concerned, whether `_modify`\n    // is run on EJSON or on mongo-converted EJSON.\n\n    // Run this code up front so that it fails fast if someone uses\n    // a Mongo update operator we don't support.\n    let knownId;\n    if (options.upsert) {\n      try {\n        let newDoc = LocalCollection._createUpsertDocument(selector, mod);\n        knownId = newDoc._id;\n      } catch (err) {\n        if (callback) {\n          return callback(err);\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    if (options.upsert &&\n        ! isModify &&\n        ! knownId &&\n        options.insertedId &&\n        ! (options.insertedId instanceof Mongo.ObjectID &&\n           options.generatedId)) {\n      // In case of an upsert with a replacement, where there is no _id defined\n      // in either the query or the replacement doc, mongo will generate an id itself.\n      // Therefore we need this special strategy if we want to control the id ourselves.\n\n      // We don't need to do this when:\n      // - This is not a replacement, so we can add an _id to $setOnInsert\n      // - The id is defined by query or mod we can just add it to the replacement doc\n      // - The user did not specify any id preference and the id is a Mongo ObjectId,\n      //     then we can just let Mongo generate the id\n\n      simulateUpsertWithInsertedId(\n        collection, mongoSelector, mongoMod, options,\n        // This callback does not need to be bindEnvironment'ed because\n        // simulateUpsertWithInsertedId() wraps it and then passes it through\n        // bindEnvironmentForWrite.\n        function (error, result) {\n          // If we got here via a upsert() call, then options._returnObject will\n          // be set and we should return the whole object. Otherwise, we should\n          // just return the number of affected docs to match the mongo API.\n          if (result && ! options._returnObject) {\n            callback(error, result.numberAffected);\n          } else {\n            callback(error, result);\n          }\n        }\n      );\n    } else {\n\n      if (options.upsert && !knownId && options.insertedId && isModify) {\n        if (!mongoMod.hasOwnProperty('$setOnInsert')) {\n          mongoMod.$setOnInsert = {};\n        }\n        knownId = options.insertedId;\n        Object.assign(mongoMod.$setOnInsert, replaceTypes({_id: options.insertedId}, replaceMeteorAtomWithMongo));\n      }\n\n      const strings = Object.keys(mongoMod).filter((key) => !key.startsWith(\"$\"));\n      let updateMethod = strings.length > 0 ? 'replaceOne' : 'updateMany';\n      updateMethod =\n        updateMethod === 'updateMany' && !mongoOpts.multi\n          ? 'updateOne'\n          : updateMethod;\n      collection[updateMethod].bind(collection)(\n        mongoSelector, mongoMod, mongoOpts,\n          // mongo driver now returns undefined for err in the callback\n          bindEnvironmentForWrite(function (err = null, result) {\n          if (! err) {\n            var meteorResult = transformResult({result});\n            if (meteorResult && options._returnObject) {\n              // If this was an upsert() call, and we ended up\n              // inserting a new doc and we know its id, then\n              // return that id as well.\n              if (options.upsert && meteorResult.insertedId) {\n                if (knownId) {\n                  meteorResult.insertedId = knownId;\n                } else if (meteorResult.insertedId instanceof MongoDB.ObjectID) {\n                  meteorResult.insertedId = new Mongo.ObjectID(meteorResult.insertedId.toHexString());\n                }\n              }\n\n              callback(err, meteorResult);\n            } else {\n              callback(err, meteorResult.numberAffected);\n            }\n          } else {\n            callback(err);\n          }\n        }));\n    }\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\nvar transformResult = function (driverResult) {\n  var meteorResult = { numberAffected: 0 };\n  if (driverResult) {\n    var mongoResult = driverResult.result;\n    // On updates with upsert:true, the inserted values come as a list of\n    // upserted values -- even with options.multi, when the upsert does insert,\n    // it only inserts one element.\n    if (mongoResult.upsertedCount) {\n      meteorResult.numberAffected = mongoResult.upsertedCount;\n\n      if (mongoResult.upsertedId) {\n        meteorResult.insertedId = mongoResult.upsertedId;\n      }\n    } else {\n      // n was used before Mongo 5.0, in Mongo 5.0 we are not receiving this n\n      // field and so we are using modifiedCount instead\n      meteorResult.numberAffected = mongoResult.n || mongoResult.matchedCount || mongoResult.modifiedCount;\n    }\n  }\n\n  return meteorResult;\n};\n\n\nvar NUM_OPTIMISTIC_TRIES = 3;\n\n// exposed for testing\nMongoConnection._isCannotChangeIdError = function (err) {\n\n  // Mongo 3.2.* returns error as next Object:\n  // {name: String, code: Number, errmsg: String}\n  // Older Mongo returns:\n  // {name: String, code: Number, err: String}\n  var error = err.errmsg || err.err;\n\n  // We don't use the error code here\n  // because the error code we observed it producing (16837) appears to be\n  // a far more generic error code based on examining the source.\n  if (error.indexOf('The _id field cannot be changed') === 0\n    || error.indexOf(\"the (immutable) field '_id' was found to have been altered to _id\") !== -1) {\n    return true;\n  }\n\n  return false;\n};\n\nvar simulateUpsertWithInsertedId = function (collection, selector, mod,\n                                             options, callback) {\n  // STRATEGY: First try doing an upsert with a generated ID.\n  // If this throws an error about changing the ID on an existing document\n  // then without affecting the database, we know we should probably try\n  // an update without the generated ID. If it affected 0 documents,\n  // then without affecting the database, we the document that first\n  // gave the error is probably removed and we need to try an insert again\n  // We go back to step one and repeat.\n  // Like all \"optimistic write\" schemes, we rely on the fact that it's\n  // unlikely our writes will continue to be interfered with under normal\n  // circumstances (though sufficiently heavy contention with writers\n  // disagreeing on the existence of an object will cause writes to fail\n  // in theory).\n\n  var insertedId = options.insertedId; // must exist\n  var mongoOptsForUpdate = {\n    safe: true,\n    multi: options.multi\n  };\n  var mongoOptsForInsert = {\n    safe: true,\n    upsert: true\n  };\n\n  var replacementWithId = Object.assign(\n    replaceTypes({_id: insertedId}, replaceMeteorAtomWithMongo),\n    mod);\n\n  var tries = NUM_OPTIMISTIC_TRIES;\n\n  var doUpdate = function () {\n    tries--;\n    if (! tries) {\n      callback(new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\"));\n    } else {\n      let method = collection.updateMany;\n      if(!Object.keys(mod).some(key => key.startsWith(\"$\"))){\n        method = collection.replaceOne.bind(collection);\n      }\n      method(\n        selector,\n        mod,\n        mongoOptsForUpdate,\n        bindEnvironmentForWrite(function(err, result) {\n          if (err) {\n            callback(err);\n          } else if (result && (result.modifiedCount || result.upsertedCount)) {\n            callback(null, {\n              numberAffected: result.modifiedCount || result.upsertedCount,\n              insertedId: result.upsertedId || undefined,\n            });\n          } else {\n            doConditionalInsert();\n          }\n        })\n      );\n    }\n  };\n\n  var doConditionalInsert = function() {\n    collection.replaceOne(\n      selector,\n      replacementWithId,\n      mongoOptsForInsert,\n      bindEnvironmentForWrite(function(err, result) {\n        if (err) {\n          // figure out if this is a\n          // \"cannot change _id of document\" error, and\n          // if so, try doUpdate() again, up to 3 times.\n          if (MongoConnection._isCannotChangeIdError(err)) {\n            doUpdate();\n          } else {\n            callback(err);\n          }\n        } else {\n          callback(null, {\n            numberAffected: result.upsertedCount,\n            insertedId: result.upsertedId,\n          });\n        }\n      })\n    );\n  };\n\n  doUpdate();\n};\n\n_.each([\"insert\", \"update\", \"remove\", \"dropCollection\", \"dropDatabase\"], function (method) {\n  MongoConnection.prototype[method] = function (/* arguments */) {\n    var self = this;\n    return Meteor.wrapAsync(self[\"_\" + method]).apply(self, arguments);\n  };\n});\n\n// XXX MongoConnection.upsert() does not return the id of the inserted document\n// unless you set it explicitly in the selector or modifier (as a replacement\n// doc).\nMongoConnection.prototype.upsert = function (collectionName, selector, mod,\n                                             options, callback) {\n  var self = this;\n  if (typeof options === \"function\" && ! callback) {\n    callback = options;\n    options = {};\n  }\n\n  return self.update(collectionName, selector, mod,\n                     _.extend({}, options, {\n                       upsert: true,\n                       _returnObject: true\n                     }), callback);\n};\n\nMongoConnection.prototype.find = function (collectionName, selector, options) {\n  var self = this;\n\n  if (arguments.length === 1)\n    selector = {};\n\n  return new Cursor(\n    self, new CursorDescription(collectionName, selector, options));\n};\n\nMongoConnection.prototype.findOne = function (collection_name, selector,\n                                              options) {\n  var self = this;\n  if (arguments.length === 1)\n    selector = {};\n\n  options = options || {};\n  options.limit = 1;\n  return self.find(collection_name, selector, options).fetch()[0];\n};\n\n// We'll actually design an index API later. For now, we just pass through to\n// Mongo's, but make it synchronous.\nMongoConnection.prototype.createIndex = function (collectionName, index,\n                                                   options) {\n  var self = this;\n\n  // We expect this function to be called at startup, not from within a method,\n  // so we don't interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  var future = new Future;\n  var indexName = collection.createIndex(index, options, future.resolver());\n  future.wait();\n};\n\nMongoConnection.prototype._ensureIndex = MongoConnection.prototype.createIndex;\n\nMongoConnection.prototype._dropIndex = function (collectionName, index) {\n  var self = this;\n\n  // This function is only used by test code, not within a method, so we don't\n  // interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  var future = new Future;\n  var indexName = collection.dropIndex(index, future.resolver());\n  future.wait();\n};\n\n// CURSORS\n\n// There are several classes which relate to cursors:\n//\n// CursorDescription represents the arguments used to construct a cursor:\n// collectionName, selector, and (find) options.  Because it is used as a key\n// for cursor de-dup, everything in it should either be JSON-stringifiable or\n// not affect observeChanges output (eg, options.transform functions are not\n// stringifiable but do not affect observeChanges).\n//\n// SynchronousCursor is a wrapper around a MongoDB cursor\n// which includes fully-synchronous versions of forEach, etc.\n//\n// Cursor is the cursor object returned from find(), which implements the\n// documented Mongo.Collection cursor API.  It wraps a CursorDescription and a\n// SynchronousCursor (lazily: it doesn't contact Mongo until you call a method\n// like fetch or forEach on it).\n//\n// ObserveHandle is the \"observe handle\" returned from observeChanges. It has a\n// reference to an ObserveMultiplexer.\n//\n// ObserveMultiplexer allows multiple identical ObserveHandles to be driven by a\n// single observe driver.\n//\n// There are two \"observe drivers\" which drive ObserveMultiplexers:\n//   - PollingObserveDriver caches the results of a query and reruns it when\n//     necessary.\n//   - OplogObserveDriver follows the Mongo operation log to directly observe\n//     database changes.\n// Both implementations follow the same simple interface: when you create them,\n// they start sending observeChanges callbacks (and a ready() invocation) to\n// their ObserveMultiplexer, and you stop them by calling their stop() method.\n\nCursorDescription = function (collectionName, selector, options) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.selector = Mongo.Collection._rewriteSelector(selector);\n  self.options = options || {};\n};\n\nCursor = function (mongo, cursorDescription) {\n  var self = this;\n\n  self._mongo = mongo;\n  self._cursorDescription = cursorDescription;\n  self._synchronousCursor = null;\n};\n\n_.each(['forEach', 'map', 'fetch', 'count', Symbol.iterator], function (method) {\n  Cursor.prototype[method] = function () {\n    var self = this;\n\n    // You can only observe a tailable cursor.\n    if (self._cursorDescription.options.tailable)\n      throw new Error(\"Cannot call \" + method + \" on a tailable cursor\");\n\n    if (!self._synchronousCursor) {\n      self._synchronousCursor = self._mongo._createSynchronousCursor(\n        self._cursorDescription, {\n          // Make sure that the \"self\" argument to forEach/map callbacks is the\n          // Cursor, not the SynchronousCursor.\n          selfForIteration: self,\n          useTransform: true\n        });\n    }\n\n    return self._synchronousCursor[method].apply(\n      self._synchronousCursor, arguments);\n  };\n});\n\nCursor.prototype.getTransform = function () {\n  return this._cursorDescription.options.transform;\n};\n\n// When you call Meteor.publish() with a function that returns a Cursor, we need\n// to transmute it into the equivalent subscription.  This is the function that\n// does that.\n\nCursor.prototype._publishCursor = function (sub) {\n  var self = this;\n  var collection = self._cursorDescription.collectionName;\n  return Mongo.Collection._publishCursor(self, sub, collection);\n};\n\n// Used to guarantee that publish functions return at most one cursor per\n// collection. Private, because we might later have cursors that include\n// documents from multiple collections somehow.\nCursor.prototype._getCollectionName = function () {\n  var self = this;\n  return self._cursorDescription.collectionName;\n};\n\nCursor.prototype.observe = function (callbacks) {\n  var self = this;\n  return LocalCollection._observeFromObserveChanges(self, callbacks);\n};\n\nCursor.prototype.observeChanges = function (callbacks, options = {}) {\n  var self = this;\n  var methods = [\n    'addedAt',\n    'added',\n    'changedAt',\n    'changed',\n    'removedAt',\n    'removed',\n    'movedTo'\n  ];\n  var ordered = LocalCollection._observeChangesCallbacksAreOrdered(callbacks);\n\n  let exceptionName = callbacks._fromObserve ? 'observe' : 'observeChanges';\n  exceptionName += ' callback';\n  methods.forEach(function (method) {\n    if (callbacks[method] && typeof callbacks[method] == \"function\") {\n      callbacks[method] = Meteor.bindEnvironment(callbacks[method], method + exceptionName);\n    }\n  });\n\n  return self._mongo._observeChanges(\n    self._cursorDescription, ordered, callbacks, options.nonMutatingCallbacks);\n};\n\nMongoConnection.prototype._createSynchronousCursor = function(\n    cursorDescription, options) {\n  var self = this;\n  options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n\n  var collection = self.rawCollection(cursorDescription.collectionName);\n  var cursorOptions = cursorDescription.options;\n  var mongoOptions = {\n    sort: cursorOptions.sort,\n    limit: cursorOptions.limit,\n    skip: cursorOptions.skip,\n    projection: cursorOptions.fields || cursorOptions.projection,\n    readPreference: cursorOptions.readPreference,\n  };\n\n  // Do we want a tailable cursor (which only works on capped collections)?\n  if (cursorOptions.tailable) {\n    mongoOptions.numberOfRetries = -1;\n  }\n\n  var dbCursor = collection.find(\n    replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo),\n    mongoOptions);\n\n  // Do we want a tailable cursor (which only works on capped collections)?\n  if (cursorOptions.tailable) {\n    // We want a tailable cursor...\n    dbCursor.addCursorFlag(\"tailable\", true)\n    // ... and for the server to wait a bit if any getMore has no data (rather\n    // than making us put the relevant sleeps in the client)...\n    dbCursor.addCursorFlag(\"awaitData\", true)\n\n    // And if this is on the oplog collection and the cursor specifies a 'ts',\n    // then set the undocumented oplog replay flag, which does a special scan to\n    // find the first document (instead of creating an index on ts). This is a\n    // very hard-coded Mongo flag which only works on the oplog collection and\n    // only works with the ts field.\n    if (cursorDescription.collectionName === OPLOG_COLLECTION &&\n        cursorDescription.selector.ts) {\n      dbCursor.addCursorFlag(\"oplogReplay\", true)\n    }\n  }\n\n  if (typeof cursorOptions.maxTimeMs !== 'undefined') {\n    dbCursor = dbCursor.maxTimeMS(cursorOptions.maxTimeMs);\n  }\n  if (typeof cursorOptions.hint !== 'undefined') {\n    dbCursor = dbCursor.hint(cursorOptions.hint);\n  }\n\n  return new SynchronousCursor(dbCursor, cursorDescription, options);\n};\n\nvar SynchronousCursor = function (dbCursor, cursorDescription, options) {\n  var self = this;\n  options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n\n  self._dbCursor = dbCursor;\n  self._cursorDescription = cursorDescription;\n  // The \"self\" argument passed to forEach/map callbacks. If we're wrapped\n  // inside a user-visible Cursor, we want to provide the outer cursor!\n  self._selfForIteration = options.selfForIteration || self;\n  if (options.useTransform && cursorDescription.options.transform) {\n    self._transform = LocalCollection.wrapTransform(\n      cursorDescription.options.transform);\n  } else {\n    self._transform = null;\n  }\n\n  self._synchronousCount = Future.wrap(dbCursor.count.bind(dbCursor));\n  self._visitedIds = new LocalCollection._IdMap;\n};\n\n_.extend(SynchronousCursor.prototype, {\n  // Returns a Promise for the next object from the underlying cursor (before\n  // the Mongo->Meteor type replacement).\n  _rawNextObjectPromise: function () {\n    const self = this;\n    return new Promise((resolve, reject) => {\n      self._dbCursor.next((err, doc) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(doc);\n        }\n      });\n    });\n  },\n\n  // Returns a Promise for the next object from the cursor, skipping those whose\n  // IDs we've already seen and replacing Mongo atoms with Meteor atoms.\n  _nextObjectPromise: async function () {\n    var self = this;\n\n    while (true) {\n      var doc = await self._rawNextObjectPromise();\n\n      if (!doc) return null;\n      doc = replaceTypes(doc, replaceMongoAtomWithMeteor);\n\n      if (!self._cursorDescription.options.tailable && _.has(doc, '_id')) {\n        // Did Mongo give us duplicate documents in the same cursor? If so,\n        // ignore this one. (Do this before the transform, since transform might\n        // return some unrelated value.) We don't do this for tailable cursors,\n        // because we want to maintain O(1) memory usage. And if there isn't _id\n        // for some reason (maybe it's the oplog), then we don't do this either.\n        // (Be careful to do this for falsey but existing _id, though.)\n        if (self._visitedIds.has(doc._id)) continue;\n        self._visitedIds.set(doc._id, true);\n      }\n\n      if (self._transform)\n        doc = self._transform(doc);\n\n      return doc;\n    }\n  },\n\n  // Returns a promise which is resolved with the next object (like with\n  // _nextObjectPromise) or rejected if the cursor doesn't return within\n  // timeoutMS ms.\n  _nextObjectPromiseWithTimeout: function (timeoutMS) {\n    const self = this;\n    if (!timeoutMS) {\n      return self._nextObjectPromise();\n    }\n    const nextObjectPromise = self._nextObjectPromise();\n    const timeoutErr = new Error('Client-side timeout waiting for next object');\n    const timeoutPromise = new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(timeoutErr);\n      }, timeoutMS);\n    });\n    return Promise.race([nextObjectPromise, timeoutPromise])\n      .catch((err) => {\n        if (err === timeoutErr) {\n          self.close();\n        }\n        throw err;\n      });\n  },\n\n  _nextObject: function () {\n    var self = this;\n    return self._nextObjectPromise().await();\n  },\n\n  forEach: function (callback, thisArg) {\n    var self = this;\n\n    // Get back to the beginning.\n    self._rewind();\n\n    // We implement the loop ourself instead of using self._dbCursor.each,\n    // because \"each\" will call its callback outside of a fiber which makes it\n    // much more complex to make this function synchronous.\n    var index = 0;\n    while (true) {\n      var doc = self._nextObject();\n      if (!doc) return;\n      callback.call(thisArg, doc, index++, self._selfForIteration);\n    }\n  },\n\n  // XXX Allow overlapping callback executions if callback yields.\n  map: function (callback, thisArg) {\n    var self = this;\n    var res = [];\n    self.forEach(function (doc, index) {\n      res.push(callback.call(thisArg, doc, index, self._selfForIteration));\n    });\n    return res;\n  },\n\n  _rewind: function () {\n    var self = this;\n\n    // known to be synchronous\n    self._dbCursor.rewind();\n\n    self._visitedIds = new LocalCollection._IdMap;\n  },\n\n  // Mostly usable for tailable cursors.\n  close: function () {\n    var self = this;\n\n    self._dbCursor.close();\n  },\n\n  fetch: function () {\n    var self = this;\n    return self.map(_.identity);\n  },\n\n  count: function () {\n    var self = this;\n    return self._synchronousCount().wait();\n  },\n\n  // This method is NOT wrapped in Cursor.\n  getRawObjects: function (ordered) {\n    var self = this;\n    if (ordered) {\n      return self.fetch();\n    } else {\n      var results = new LocalCollection._IdMap;\n      self.forEach(function (doc) {\n        results.set(doc._id, doc);\n      });\n      return results;\n    }\n  }\n});\n\nSynchronousCursor.prototype[Symbol.iterator] = function () {\n  var self = this;\n\n  // Get back to the beginning.\n  self._rewind();\n\n  return {\n    next() {\n      const doc = self._nextObject();\n      return doc ? {\n        value: doc\n      } : {\n        done: true\n      };\n    }\n  };\n};\n\n// Tails the cursor described by cursorDescription, most likely on the\n// oplog. Calls docCallback with each document found. Ignores errors and just\n// restarts the tail on error.\n//\n// If timeoutMS is set, then if we don't get a new document every timeoutMS,\n// kill and restart the cursor. This is primarily a workaround for #8598.\nMongoConnection.prototype.tail = function (cursorDescription, docCallback, timeoutMS) {\n  var self = this;\n  if (!cursorDescription.options.tailable)\n    throw new Error(\"Can only tail a tailable cursor\");\n\n  var cursor = self._createSynchronousCursor(cursorDescription);\n\n  var stopped = false;\n  var lastTS;\n  var loop = function () {\n    var doc = null;\n    while (true) {\n      if (stopped)\n        return;\n      try {\n        doc = cursor._nextObjectPromiseWithTimeout(timeoutMS).await();\n      } catch (err) {\n        // There's no good way to figure out if this was actually an error from\n        // Mongo, or just client-side (including our own timeout error). Ah\n        // well. But either way, we need to retry the cursor (unless the failure\n        // was because the observe got stopped).\n        doc = null;\n      }\n      // Since we awaited a promise above, we need to check again to see if\n      // we've been stopped before calling the callback.\n      if (stopped)\n        return;\n      if (doc) {\n        // If a tailable cursor contains a \"ts\" field, use it to recreate the\n        // cursor on error. (\"ts\" is a standard that Mongo uses internally for\n        // the oplog, and there's a special flag that lets you do binary search\n        // on it instead of needing to use an index.)\n        lastTS = doc.ts;\n        docCallback(doc);\n      } else {\n        var newSelector = _.clone(cursorDescription.selector);\n        if (lastTS) {\n          newSelector.ts = {$gt: lastTS};\n        }\n        cursor = self._createSynchronousCursor(new CursorDescription(\n          cursorDescription.collectionName,\n          newSelector,\n          cursorDescription.options));\n        // Mongo failover takes many seconds.  Retry in a bit.  (Without this\n        // setTimeout, we peg the CPU at 100% and never notice the actual\n        // failover.\n        Meteor.setTimeout(loop, 100);\n        break;\n      }\n    }\n  };\n\n  Meteor.defer(loop);\n\n  return {\n    stop: function () {\n      stopped = true;\n      cursor.close();\n    }\n  };\n};\n\nMongoConnection.prototype._observeChanges = function (\n    cursorDescription, ordered, callbacks, nonMutatingCallbacks) {\n  var self = this;\n\n  if (cursorDescription.options.tailable) {\n    return self._observeChangesTailable(cursorDescription, ordered, callbacks);\n  }\n\n  // You may not filter out _id when observing changes, because the id is a core\n  // part of the observeChanges API.\n  const fieldsOptions = cursorDescription.options.projection || cursorDescription.options.fields;\n  if (fieldsOptions &&\n      (fieldsOptions._id === 0 ||\n       fieldsOptions._id === false)) {\n    throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n  }\n\n  var observeKey = EJSON.stringify(\n    _.extend({ordered: ordered}, cursorDescription));\n\n  var multiplexer, observeDriver;\n  var firstHandle = false;\n\n  // Find a matching ObserveMultiplexer, or create a new one. This next block is\n  // guaranteed to not yield (and it doesn't call anything that can observe a\n  // new query), so no other calls to this function can interleave with it.\n  Meteor._noYieldsAllowed(function () {\n    if (_.has(self._observeMultiplexers, observeKey)) {\n      multiplexer = self._observeMultiplexers[observeKey];\n    } else {\n      firstHandle = true;\n      // Create a new ObserveMultiplexer.\n      multiplexer = new ObserveMultiplexer({\n        ordered: ordered,\n        onStop: function () {\n          delete self._observeMultiplexers[observeKey];\n          observeDriver.stop();\n        }\n      });\n      self._observeMultiplexers[observeKey] = multiplexer;\n    }\n  });\n\n  var observeHandle = new ObserveHandle(multiplexer,\n    callbacks,\n    nonMutatingCallbacks,\n  );\n\n  if (firstHandle) {\n    var matcher, sorter;\n    var canUseOplog = _.all([\n      function () {\n        // At a bare minimum, using the oplog requires us to have an oplog, to\n        // want unordered callbacks, and to not want a callback on the polls\n        // that won't happen.\n        return self._oplogHandle && !ordered &&\n          !callbacks._testOnlyPollCallback;\n      }, function () {\n        // We need to be able to compile the selector. Fall back to polling for\n        // some newfangled $selector that minimongo doesn't support yet.\n        try {\n          matcher = new Minimongo.Matcher(cursorDescription.selector);\n          return true;\n        } catch (e) {\n          // XXX make all compilation errors MinimongoError or something\n          //     so that this doesn't ignore unrelated exceptions\n          return false;\n        }\n      }, function () {\n        // ... and the selector itself needs to support oplog.\n        return OplogObserveDriver.cursorSupported(cursorDescription, matcher);\n      }, function () {\n        // And we need to be able to compile the sort, if any.  eg, can't be\n        // {$natural: 1}.\n        if (!cursorDescription.options.sort)\n          return true;\n        try {\n          sorter = new Minimongo.Sorter(cursorDescription.options.sort);\n          return true;\n        } catch (e) {\n          // XXX make all compilation errors MinimongoError or something\n          //     so that this doesn't ignore unrelated exceptions\n          return false;\n        }\n      }], function (f) { return f(); });  // invoke each function\n\n    var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver;\n    observeDriver = new driverClass({\n      cursorDescription: cursorDescription,\n      mongoHandle: self,\n      multiplexer: multiplexer,\n      ordered: ordered,\n      matcher: matcher,  // ignored by polling\n      sorter: sorter,  // ignored by polling\n      _testOnlyPollCallback: callbacks._testOnlyPollCallback\n    });\n\n    // This field is only set for use in tests.\n    multiplexer._observeDriver = observeDriver;\n  }\n\n  // Blocks until the initial adds have been sent.\n  multiplexer.addHandleAndSendInitialAdds(observeHandle);\n\n  return observeHandle;\n};\n\n// Listen for the invalidation messages that will trigger us to poll the\n// database for changes. If this selector specifies specific IDs, specify them\n// here, so that updates to different specific IDs don't cause us to poll.\n// listenCallback is the same kind of (notification, complete) callback passed\n// to InvalidationCrossbar.listen.\n\nlistenAll = function (cursorDescription, listenCallback) {\n  var listeners = [];\n  forEachTrigger(cursorDescription, function (trigger) {\n    listeners.push(DDPServer._InvalidationCrossbar.listen(\n      trigger, listenCallback));\n  });\n\n  return {\n    stop: function () {\n      _.each(listeners, function (listener) {\n        listener.stop();\n      });\n    }\n  };\n};\n\nforEachTrigger = function (cursorDescription, triggerCallback) {\n  var key = {collection: cursorDescription.collectionName};\n  var specificIds = LocalCollection._idsMatchedBySelector(\n    cursorDescription.selector);\n  if (specificIds) {\n    _.each(specificIds, function (id) {\n      triggerCallback(_.extend({id: id}, key));\n    });\n    triggerCallback(_.extend({dropCollection: true, id: null}, key));\n  } else {\n    triggerCallback(key);\n  }\n  // Everyone cares about the database being dropped.\n  triggerCallback({ dropDatabase: true });\n};\n\n// observeChanges for tailable cursors on capped collections.\n//\n// Some differences from normal cursors:\n//   - Will never produce anything other than 'added' or 'addedBefore'. If you\n//     do update a document that has already been produced, this will not notice\n//     it.\n//   - If you disconnect and reconnect from Mongo, it will essentially restart\n//     the query, which will lead to duplicate results. This is pretty bad,\n//     but if you include a field called 'ts' which is inserted as\n//     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the\n//     current Mongo-style timestamp), we'll be able to find the place to\n//     restart properly. (This field is specifically understood by Mongo with an\n//     optimization which allows it to find the right place to start without\n//     an index on ts. It's how the oplog works.)\n//   - No callbacks are triggered synchronously with the call (there's no\n//     differentiation between \"initial data\" and \"later changes\"; everything\n//     that matches the query gets sent asynchronously).\n//   - De-duplication is not implemented.\n//   - Does not yet interact with the write fence. Probably, this should work by\n//     ignoring removes (which don't work on capped collections) and updates\n//     (which don't affect tailable cursors), and just keeping track of the ID\n//     of the inserted object, and closing the write fence once you get to that\n//     ID (or timestamp?).  This doesn't work well if the document doesn't match\n//     the query, though.  On the other hand, the write fence can close\n//     immediately if it does not match the query. So if we trust minimongo\n//     enough to accurately evaluate the query against the write fence, we\n//     should be able to do this...  Of course, minimongo doesn't even support\n//     Mongo Timestamps yet.\nMongoConnection.prototype._observeChangesTailable = function (\n    cursorDescription, ordered, callbacks) {\n  var self = this;\n\n  // Tailable cursors only ever call added/addedBefore callbacks, so it's an\n  // error if you didn't provide them.\n  if ((ordered && !callbacks.addedBefore) ||\n      (!ordered && !callbacks.added)) {\n    throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\")\n                    + \" tailable cursor without a \"\n                    + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n  }\n\n  return self.tail(cursorDescription, function (doc) {\n    var id = doc._id;\n    delete doc._id;\n    // The ts is an implementation detail. Hide it.\n    delete doc.ts;\n    if (ordered) {\n      callbacks.addedBefore(id, doc, null);\n    } else {\n      callbacks.added(id, doc);\n    }\n  });\n};\n\n// XXX We probably need to find a better way to expose this. Right now\n// it's only used by tests, but in fact you need it in normal\n// operation to interact with capped collections.\nMongoInternals.MongoTimestamp = MongoDB.Timestamp;\n\nMongoInternals.Connection = MongoConnection;\n"]},"sourceType":"module","externalDependencies":{},"hash":"9109011812f1c525c500d7204779f27035eae333"}
